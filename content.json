{"meta":{"title":"Lu's Blog","subtitle":null,"description":"好少年光芒万丈","author":"simonlu","url":""},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, there111👋\" }).then(function () { botui.message.add({ delay: 1100, content: \"这里是 Mashiro\" }).then(function () { botui.message.add({ delay: 1100, content: \"一个可爱的蓝孩子~\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function () { botui.message.add({ delay: 600, content: \"😘\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function () { botui.message.add({ delay: 1500, content: \"目前就读于上海财经大学\" }).then(function () { botui.message.add({ delay: 1500, content: \"向往技术却误入商科，但后来喜欢上了经济学…\" }).then(function () { botui.message.add({ delay: 1200, content: \"因为数据分析也需要Coder嘛\" }).then(function () { botui.message.add({ delay: 1500, content: \"主攻 R 语言和 Python，略懂 STATA，偶尔也折腾 HTML/CSS/JavaScript/PHP\" }).then(function () { botui.message.add({ delay: 1500, content: \"研究的方向，是经济/金融方向的数据分析（data science）以及机器学习（machine learning）\" }).then(function () { botui.message.add({ delay: 1800, content: \"喜欢画画，希望有一天能够被称为画师\" }).then(function () { botui.action.button({ delay: 1100, action: [{ text: \"为什么叫Mashiro呢？ 🤔\", value: \"why-mashiro\" }] }).then(function (a) { thirdpart() }) }) }) }) }) }) }) }, thirdpart = function () { botui.message.add({ delay: 1E3, content: \"Mashiro以及站名都来自一部动画，因为和主角有一样的爱好~ 如果有兴趣可以找找首页上的视频~\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"为什么是白猫呢？ 🤔\", value: \"why-cat\" }] }).then(function (a) { fourthpart() }) }) }, fourthpart = function () { botui.message.add({ delay: 1E3, content: \"因为对GitHub有种执念… \" }).then(function () { botui.message.add({ delay: 1100, content: \"而且我真的是猫控！\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"域名有什么含意吗？(ง •_•)ง\", value: \"why-domain\" }] }).then(function (a) { fifthpart() }) }) }) }, fifthpart = function () { botui.message.add({ delay: 1E3, content: \"emmmm，看备案信息你就知道了=.= 本来想要zheng.xin的，但50万真买不起。。\" }).then(function () { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧？ ^_^\" }) }) } } bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-07-30T03:29:40.307Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"enjoy","date":"2019-07-30T03:29:30.351Z","updated":"2019-07-30T03:29:30.351Z","comments":false,"path":"movie/index.html","permalink":"/movie/index.html","excerpt":"","text":".hexo-image-steam-lazy {display:block;}.hexo-img-stream{width:90%;max-width:1100px;margin:3% auto}div.hexo-img-stream figure{background:#fefefe;box-shadow:0 1px 2px rgba(34,25,25,0.4);margin:0 0.05% 3%;padding:3%;padding-bottom:10px;display:inline-block;max-width:19.4%}div.hexo-img-stream figure img{border-bottom:1px solid #ccc;padding-bottom:15px;margin-bottom:5px}div.hexo-img-stream figure figcaption{font-size:.9rem;color:#444;line-height:1.5;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;text-align:center;}div.hexo-img-stream small{font-size:1rem;float:right;text-transform:uppercase;color:#aaa}div.hexo-img-stream small a{color:#666;text-decoration:none;transition:.4s color}@media screen and (max-width:750px){.hexo-img-stream{column-gap:0}} 撞车 不羁夜 杯酒人生 昆池岩 午夜巴塞罗那 硅谷 告白 复仇者联盟3：无限战争 血观音 春夏秋冬又一春 狂暴巨兽 大佛普拉斯 头号玩家 水形物语 与神同行 伯德小姐 红海行动 月球 芳华 太阳照常升起 请以你的名字呼唤我 铁雨 情书 家有喜事 勇往直前 异形：契约 银翼杀手2049 银翼杀手 电锯惊魂8：竖锯 三块广告牌 风筝 星球大战8：最后的绝地武士 寻梦环游记 尼罗河上的惨案 黑镜第四季 无耻之徒第八季 去他*的世界 怪奇物语第二季 忌日快乐 $(\"img.hexo-image-steam-lazy\").lazyload({ effect:\"fadeIn\" });"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-07-26T11:25:07.308Z","updated":"2019-07-26T11:25:07.308Z","comments":true,"path":"2019/07/26/hello-world/","link":"","permalink":"/2019/07/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"如何使用GDB调试项目","slug":"如何使用GDB调试项目","date":"2019-06-03T06:51:25.000Z","updated":"2019-07-24T17:54:28.402Z","comments":true,"path":"2019/06/03/如何使用GDB调试项目/","link":"","permalink":"/2019/06/03/如何使用GDB调试项目/","excerpt":"","text":"-g 可在编译后的程序中保留调试符号信息strip hello_server 移除程序中存在的调试信息，程序测试后没有问题，我们可以使用此命令减小程序体积调试文件时建议关闭编译器优化选项，有可能会优化掉排查的对象 三种调试方式： gdb filename 直接调试目标程序，然后 run gdb attach pid 程序已经启动，将 gdb 调试器附加到程序上，ps 命令获取改进程的 pid结束调试后使用 detach 来分离 gdb filename corename 程序崩溃时有 core 文件产生，可以使用 core 来定位问题ulimit -c 查看是否开启了之一机制 ulimit -a 系统最大文件描述符“ulimit 选项名 设置值”来修改，例：ulimit -c unlimited,永久生效需要将此命令加入/etc/profile 文件中core 文件的默认名字是 core.pid core 文件针对 core 文件，pid 在程序崩溃时候无法获取 pid，尤其多个程序同时崩溃时，解决方法有两个： 程序启动时候,记录自己的 pid void writepid() { uint31_t curPid = (uint32_t) getpid(); FILE* f = fopen(&quot;xxxserver.pid&quot;, &quot;w&quot;); assert(f); char szPid[32]; snprintf(szPid, sizeof(szPid), &quot;%d&quot;, curPid); fwrite(szPid, strlen(szPid), 1, f); fclose(f); } // 生成的pid记录到xxxserver.pd文件中，崩溃时从此获取 自定义 core 文件的名称和目录/proc/sys/kernel/core_uses_pid 可以控制产生的 core 文件的文件名是否用 pid 作为扩展名，1 为添加，0 则否/proc/sys/kernel/core_pattern 可以设置格式化的 core 文件保存位置和文件名，命令如下： echo &quot;/corefile/core-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern %e 代表充程序名，%p 代表 pid, %t 代表时间戳 例如/testcore/core-%e-%p-%t，将生成 core-test-13154-1547445291 这种格式 常用命令 命令名称 缩写 说明 run r 运行 continue c 暂停的程序继续运行 next n 运行到下一行 step u 如果有函数，进入内部 until u 运行到指定行停下来 finish fi 结束当前调用函数，到上一层函数调用处 return return 结束当前调用函数并返回指定值，到上一层函数调用处 jump j 执行流跳转到指定行或地址 print p 打印变量或寄存器值 backtrace bt 查看当前线程调用堆栈 frame f 切换到当前线程调用的指定堆栈，可通过堆栈序号 thread thread 切换到指定线程 break b 添加断点 tbreak tb 添加临时断点 delete del 删除断点 enable enable 启用某个断点 disable disable 禁用某个断点 wathc watch 监视某一个变量或地址的值是否变化 list l 显示源码 info info 显示断点/线程等信息 ptype ptype 查看变量类型 disassemble dis 查看汇编代码 set args 设置程序启动命令行参数 show args 查看设置的命令行参数 print 和 ptype print 不仅可以显示变量值，也可以进行一定运算表达式计算结果，甚至可以显示一些函数的执行结果 p &amp;server.port 取地址，在 C++对象中，也可以 p this,也可以 p *this 列出当前对象各个成员的值 p a+b+c 来打印三个变量的计算结果，func()是可执行函数，也可以 p func()输出该变量的执行结果 print 也可以修改变量的值 info 和 thread info thread 查看当前进程有哪些线程, 带*号表示当前 gdb 作用于哪个线程，谁是主线程可以 bt 查看调用堆栈 thread 线程编号 切换线程 info args 产看当前函数的参数值 next、step、until、jump 函数调用方式_cdelc 和_stdcall，C++非静态成员函数的调用方式_thiscall，函数参数的传递本质都是函数参数入栈的过程，者三种入栈方式都是从右往左的 直接执行完当前函数并回到上一层调用处，使用 finish return 与之类似，可以指定该函数返回值Note: finish 会执行函数到函数正常退出该函数；而 return 是立即结束当前函数并返回，如果说当前函数还有剩余的代码未执行完毕，也不会执行了 until 快速执行完中间代码 jump location 可以是行号或者函数的地址，行为是不可控的如果 jump 跳转的位置后续没有断点，gdb 会执行完跳转处的代码继续执行jump 妙用：可以执行一些我们想要执行的代码，可能这些代码在正常逻辑下不会执行,如下： int main() { int a = 0; if (a != 0 ) { printf(&quot;if condition\\n&quot;); } else { orintf(&quot;else condition\\n&quot;); } return 0; } 正常是走 else 分支，可以使用 jump 强制走 if,return 0 设为断点，gdb 会停下 disassemble disassemble 查看汇编指令，默认为 AT&amp;T 格式，可以通过 show disassembly-flavor 查看，通过 set disassembly-flavor intel 设置为 intel 汇编格式 set args 和 show argsgdb filename args 是错误做法，应该是 gdb 附加程序后，在 run 命令前，使用”set args 参数内容”来设置，例如：set args ../redis.conf如果单个命令行参数之间含有空格，可以使用引号将参数包裹起来，如：set args “999 xx” “hu jj”清楚参数，直接使用 set args 不加任何参数 tbreak 该断点触发一次就会自动删除 watch 通过添加硬件断点来达到监视数据变化的目的，有以下几种形式:(1) 整形变量, int i; wathc i(2) 指针类型， char p; watch p 与 wathc p,两种是有区别的(3) 一个数组或内存区间， char buf[128]; wathc buf display 命令监视的变量或者内存地址，每次程序中断下来都会自动输出这些变量或者内存的值info display 查看， delete display 清除全部需自动输出的变量，加编号删除某一个display \\$ebp 添加寄存器 ebp 调试技巧 print 打印结果显示完整打印字符串或字符数组时，字符串太长显示不全，使用 set print element 0 命令设置就可以完整显示了 gdb 调试的程序接收信号例如 Ctrl+C(对应信号 SIGINT)，Ctrl+C 会被 gdb 接收到，程序无法接收，两种方式:(1) gdb 中使用 signal 函数手动发送信号给程序， signal SIGINT;(2) 改变 gdb 信号处理的设置，通过 handle SIGINT nostop print pass 告诉 gdb 接收到 SIGINT 不要停止，传给程序 函数存在，但是添加断点无效这时候需要改变方式，使用代码文件和行号这种方式 多线程下禁止线程切换set scheduler-locking on 将执行流锁定在当前调试线程 条件断点break [lineNo] if [condition]还有一种方式，先添加断点，然后使用”condition 断点编号 断点触发条件”，例如: (gdb)b 11 (gdb) condition 1 i == 500 gdb 调试多进程(1)先调试父进程，子进程 fork 出来后，使用 gdb attach 到子进程，这需要重新开一个 session 窗口调试(2)gdb 提供了一个选项 follow-fork,可以使用 show follow-fork mode 查看当前值，也可以通过 set follow-fork mode 设置是当一个进程 fork 出新的子进程时，gdb 是继续调试父进程还是子进程(取值 child)，默认取(parent) 自定义 gdb 调试命令在当前用户(home)目录下，root(/root),非 root(/home/用户名)下，自定义.gdbinit 文件 Redis 的调试","categories":[],"tags":[{"name":"GDB","slug":"GDB","permalink":"/tags/GDB/"}],"keywords":[]},{"title":"linux服务器端开发常用的命令","slug":"linux服务器端开发常用的命令","date":"2019-05-18T07:54:56.000Z","updated":"2019-07-24T15:56:15.262Z","comments":true,"path":"2019/05/18/linux服务器端开发常用的命令/","link":"","permalink":"/2019/05/18/linux服务器端开发常用的命令/","excerpt":"","text":"ncnc -v -p 9999 127.0.0.1 3000","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"/tags/linux/"}],"keywords":[]},{"title":"【深度探索C++对象模型】读书笔记","slug":"【深度探索C-对象模型】读书笔记","date":"2019-05-06T12:39:58.000Z","updated":"2019-07-25T01:48:19.316Z","comments":true,"path":"2019/05/06/【深度探索C-对象模型】读书笔记/","link":"","permalink":"/2019/05/06/【深度探索C-对象模型】读书笔记/","excerpt":"","text":"第一章 关于对象关于封装后的布局成本封装后Point3d并没有增加成本，data member直接内含在每一个class object中，member function不再object中，每一个non-inline member function只会诞生一个函数实例。每一个inline function则会在每一个使用者身上产生一个实例。 C++的布局以及存取时间上的额外负担是由virtual引起的，主要是virtual function和virtual base class。 C++对象模式class data member： static和nonstaticclass member function ：static、nonstatic和virtual 简单对象模型 每一个data member或function member都有一个自己的slot 表格驱动模型 一个data member table和一个member function table，class object本身内含指向这两个表的指针 C++对象模型 关键词的差异C所支持的struct和C++支持的class有一个观念的差异，但是关键词本身不提供这种差异，struct默认是有一个public接口的声明，但是也可以替代class声明public、private、protect C struct在C++中的一个合理用途，当你要传递“一个复杂的class object的全部或部分”到某个C函数去时，struct声明可以讲数据封装起来， 并保证拥有与C兼容的空间布局。注：这种保证只在组合的情况下存在，如果是“继承”而不是“组合”，编译器会决定是否有额外的data member被安插到base struct subobject之中。 对象的差异 程序模型 抽象数据模型 (ADT) 面向对象模型（OO） 纯粹以一种paradigm写程序，有助于整体的良好稳固，混合了多种，会带来一些不好的后果。如完成某种多态时，虽然可以直接或间接处理继承体系中的一个base class object，但只有通过pointer或reference的间接处理，才支持OO程序设计所需的多态性质。ADT中，程序员处理的是一个拥有固定而单一类型的实例，它在编译期就已经完全定义好了。 C++以下列方法支持多态： 经由一组隐式的转化操作，例如把一个derived class指针转化为一个指向其public base type指针 经由virtual function机制 经由dynamic_cast和typeid运算符 一个class object的大小： nonstatic data member的总和大小 由于alignemt的指针需求而填补(padding)上去的空间 由于virtual而由内部产生的任何额外负担 “指针类型”会教导编译器如何解释某个特定地址的内存内容及其大小这也是为什么一个类型为void*的只能够持有一个地址，而不能通过它操作所指之object的缘故 class ZooAnimal { public: ZooAnimal(); virtual ~ZooAnimal(); virtual void rotate(); protected: int loc; string name; }; 在VS中查看某个类的内存布局，在project Property-&gt;Configuration Properties-&gt;C/C++-&gt;Command Line写入/d1 reportSingleClassLayoutZooAnimal，build后就可以在输出中看到此类的内存布局所有类的内存布局命令为/d1 reportAllClassLayout由此可见，string默认大小为28bytes class Bear : public ZooAnimal { public: Bear(); ~Bear(); void rotate(); virtual void dance(); protected: enum Dance {}; Dance dances_know; int cell_block; }; 第二章 构造函数语意学Default Constructor的构造操作什么是默认构造函数？是可以不用实参进行调用的构造函数，包含两种情况： 没有带明显形参的构造函数（this指针） 提供了默认实参的构造函数 default constructors 在需要的时候被编译器产生出来 区分被编译器需要和被程序员需要，例如下例： class A { public: bool isTrue; int num; }; int main() { A a; if (a.isTrue) cout &lt;&lt; a.num; return 0; } 上面代码中，编译器不会为类合成默认构造函数，这种“被需要”是对程序员来说的 以下四种情况的类，编译器总是需要默认构造函数来完成某些工作： “带有Default Constructor”的Member Class Object 如果一个class没有任何constructor，但它内含一个member object，而后者有default constructor，那么编译器就需要为该class合成出一个default constructor，不过这个合成操作只有在constructor真正需要被调用时才会发生 编译器为了避免合成多个default constructor，会把合成的default constructor、copy constructor、destructor、assignment copy operator都以inline方式完成，如果函数太复杂，不适合做成inline，就会合成一个explict non-line static实例。 如果有多个class member objects，会按照member声明的顺序，调用每一个member所惯量的default constructor，这些代码会安插在explict user code前面。 “带有Default Constructor”的Base Class 如果一个没有任何constructor的class派生自一个“带有default constructor”的base class，此class的default constructor需要合成出来。它将调用base classes的default constructor（根据它们的声明顺序）。 如果设计者提供了多个constructors，但都没有default constructor，编译器不会合成一个新的default constructor，而是会将必要的default constructor的代码加入每一个构造函数中去。 如果同时存在“带有default constructors”的member object，那些default constructor也会被调用——在所有base class constructor都被调用后。 “带有一个virtual function”的class 两种情况：类本身定义了自己的虚函数和类从继承体系中继承了虚函数（成员函数一旦被声明为虚函数，继承不会改变虚函数的“虚性质”） 每个含有虚函数的类对象都有一个虚表指针vptr，编译器需要对bptr设置初值来满足虚函数机制的正确运行，编译器会把这个设置初值的操作放在默认构造函数中。对于没声明任何construtor的class，编译器会默认合成一个default constructor，有的话，则是插入一些代码在constructor中。 “带有一个virtual base class”的class 虚基类的概念存在于类与类之间，是一种相对的概念。例如类A虚继承于类X，则对于A来说，类X是类A的虚基类，而不能说类X就是一个虚基类。 virtual base class实现的共同点都是必须使virtual base class在每一个derived class object中的位置，能够于执行期准备妥当。 需要一个指针__vbcX，指向virtual base class X 以上四种情况，总结起来就是： 调用对象成员或基类的默认构造函数 为对象初始化虚表指针或虚基类指针 下面是两种常见的误解： 如果class没有定义default constructor，就会被合成出来一个 编译器合成的default constructor会对显式设定“class内每一个data member的默认值” Copy Constructor的操作如果class没有声明copy constructor，内部是使用default memberwise initialization来完成的，拷贝data member的值（例如指针地址，不拷贝内容），对于成员对象，递归实行memberwise initialization。 copy constructors只有在必要的时候才有编译器产生出来 “必要”意指class不展现bitwise copy sematics时，同样也是四种情况 含有“带有copy constructor”属性的类 基类“带有copy constructor” 带有一个或多个virtual function （需要调整vptr的指针） ZooAnimal franny = yogi; // 发生了slice，franny中vptr应该调整，不能指向Bear的虚表 带有一个或多个virtual base class 设定virtual base class pointer/offset 程序转化语意学关于NRV优化 是否需要copy constructor？大量的传值操作，编译器支持NRV的情况提供直接使用memcpy效率更高，但对于含有virtual function或内含virtual base class，不可使用memset和memcpy，会修改编译器产生的初值。 成员们的初始化队伍必须使用member initialization的四种情况： 初始化一个reference member 初始化一个const member 调用一个base class的constructor，而它拥有一组参数 调用一个member class的constructor，而它拥有一组参数 初始化顺序是按照class中member的声明顺序决定的编译器一一操作initialization list，以适当顺序在constructor内安插初始化操作，并且在任何explict user code之前。 第三章 Data语意学参考链接：C++ 合成默认构造函数的真相","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"/tags/C-C/"}],"keywords":[]},{"title":"LeetCode中遇到的问题","slug":"调试LeetCode-107所得到的教训","date":"2019-03-10T17:19:45.000Z","updated":"2019-07-24T17:59:46.664Z","comments":true,"path":"2019/03/11/调试LeetCode-107所得到的教训/","link":"","permalink":"/2019/03/11/调试LeetCode-107所得到的教训/","excerpt":"","text":"LeetCode 107 vector的insert问题在LeetCode 107题目中，本来是一个简单的遍历问题，但是由于我对vector的insert用法的不熟悉，导致出现了一个bug,最后通过调试发现inset进去的是一个{}，结果就是没效果，size还是没有改变，后来改用下面这种就可以了。 vector&lt;vector&lt;int&gt;&gt; ans; // before ans.insert(ans.begin(), {}); // after ans.insert(ans.begin(), vector&lt;int&gt;{}); 处理string对象常用方法： isalnum() : 是否是字母或数字 isalpha() : 是否是字母 isdigit() : 是否是数字 ispunct() : 是否是标点符号 isspace() : 是否是空白字符 isupper() : 是否是大写字符 isxdigit() : 是否是十六进制 toupper() : tolower() :","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"/tags/LeetCode/"}],"keywords":[]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura - 副本","date":"2018-12-12T14:16:01.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura - 副本/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura - 副本/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"二维数组的创建","slug":"二维数组的创建","date":"2018-09-09T15:03:54.000Z","updated":"2019-07-24T18:00:19.692Z","comments":true,"path":"2018/09/09/二维数组的创建/","link":"","permalink":"/2018/09/09/二维数组的创建/","excerpt":"","text":"最近在刷oj在使用二维数组的时候老是出现一些失误，所以总结一下作为备忘录吧。 方法一int row, column; cin &gt;&gt; row &gt;&gt; column; int **a = new int*[row]; for (int i = 0; i &lt; row; i++) { a[i] = new int[column]; } 方法二(利用vector)int row, column; cin &gt;&gt; row &gt;&gt; column; vector&lt;vector&lt;int&gt;&gt; a(row, vector&lt;int&gt;(column));","categories":[],"tags":[],"keywords":[]},{"title":"美团后台开发电话面试","slug":"美团后台开发电话面试","date":"2018-08-29T15:56:00.000Z","updated":"2019-03-10T02:31:12.000Z","comments":true,"path":"2018/08/29/美团后台开发电话面试/","link":"","permalink":"/2018/08/29/美团后台开发电话面试/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"一个远古的小游戏——贪吃蛇","slug":"一个远古的小游戏——贪吃蛇","date":"2018-06-13T16:08:05.000Z","updated":"2019-03-10T02:31:12.000Z","comments":true,"path":"2018/06/14/一个远古的小游戏——贪吃蛇/","link":"","permalink":"/2018/06/14/一个远古的小游戏——贪吃蛇/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"记一次大数据流量分析的实践","slug":"记一次大数据流量分析的实践","date":"2018-06-05T10:50:23.000Z","updated":"2019-07-24T15:27:30.391Z","comments":true,"path":"2018/06/05/记一次大数据流量分析的实践/","link":"","permalink":"/2018/06/05/记一次大数据流量分析的实践/","excerpt":"","text":"一、数据处理思路1.1 源文件的处理本次实验的开发环境为Ubuntu16.04，文件的格式为txt，对此我们需要将文件读入，使用pandas将其变成DataFrame形式的，便于我们后面的数据处理和分析。 # 数据处理 txt = np.loadtxt(‘record_data.txt’, skiprows=1, dtype=str) data = pd.DataFrame(txt) # 加上columns data.columns = [‘time’, ‘username’, ‘ip’, ‘mac’, ‘hostgrpid’, ‘hostname’,‘hittimes’, ‘Y_usrgrp_id’] 1.2 对字段的分析和处理如下图所示为data的前几行数据,使用data.info()和data.describe()可以看出数据并无缺失，所以我们无需填补或删除其他数据，下面是数据的每个字段的介绍。 time:时间戳，1970-01-01以来的秒数 username:用户名，已经匿名化处理了 ip、mac:上网使用的ip和mac地址 hostgrpid:hostname的分组,没有的对应为0 hostname:访问url的主机domain hittimes:一分钟访问此url的个数 Y_usrgrp_id:用户的分组id,最后实际匹配的结果 从统计的结果来看,共有325042条件记录，共有84名用户，90个ip地址,8个mac地址,可以得出用户与ip基本是一一对应的关系，除了少数用户有多个ip地址的情况除外；hostgrpid已经包含了hostname的信息，后面我们可以不使用hostname;最后,Y_usrgrp_id可以分成4类。 首先我们现处理时间： # 处理时间 data.time = pd.to_datetime(data.time, unit=’s’, utc=False) data[‘time’].describe() 可以看出数据集是从2016-10-16 16:00到2016-10-21 15:59期间的数据，详细如下图： 1.3 类型的转换由上分析可以得出，需要将mac地址由string转换int类型，ip和time也是如此，由于mac地址比较少，我们进行手动替换，而对于ip、time和hostgrpid，我们使用sklearn提供的factorize()函数来实现。 # 处理mac data.groupby([&#39;mac&#39;]).count() # 先看下都有哪些mac mac_mapping = {&#39;002421124182&#39;: 1, &#39;00E0665DC263&#39;: 2,&#39;1C6F65DCCE50&#39;: 3, &#39;246968752E49&#39;: 4, &#39;3CE5A679D42A&#39;: 5, &#39;6C5AB5B07ECE&#39;: 6, &#39;B0518E0500B0&#39;: 7, &#39;B8975A475509&#39;: 8} for k, v in mac_mapping.items(): data.loc[data[&#39;mac&#39;] ==k,&#39;mac&#39;] = v # 处理ip data[&#39;ip&#39;] = pd.factorize(data[&#39;ip&#39;])[0] # 处理hostgrpid data[&#39;hostgrpid&#39;] = pd.factorize(data[&#39;hostgrpid&#39;])[0] 在处理时间前，我们可以进一步分析下：上网访问时间较晚的员工可能属于技术类人员，所以我们可以将时间分成上班时间和下班时间，具体如下: # 分为上下班时间 data[&#39;worktime&#39;] = pd.to_datetime(data[&#39;time&#39;], unit=&#39;s&#39;) data[&#39;worktime&#39;] = data[&#39;worktime&#39;].apply(lambda x: 1 if 9 &lt;= x.hour &lt;=17 else 2) # 处理time data[&#39;time&#39;] = pd.factorize(data[&#39;time&#39;])[0] 1.4 特征的选择我们应该尽可能使用多的特征，所以我们丢掉username和hostname,因为hostgrpid已经包含了hostname的信息，代码如下： # drop username hostname data = data.drop([&#39;username&#39;,&#39;hostname&#39;], axis=1) 1.5 数据划分我们使用75%为训练集，25%为测试集，首先我们调下columns的顺序，将分类标签Y_usrgrp_id放到后面，方便我们划分，具体实现如下： # 调下列的顺序 data = data[[&#39;time&#39;, &#39;ip&#39;, &#39;mac&#39;, &#39;hostgrpid&#39;, &#39;hittimes&#39;, &#39;worktime&#39;, &#39;Y_usrgrp_id&#39;]] # 划分数据 from sklearn.model_selection import train_test_split X, y = data.iloc[:, :-1].values, data.iloc[:, -1].values X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42) 模型的选择2.1 预测模型我们简单选了几个经典的分类模型，有逻辑回归、knn、决策树、朴素贝叶斯、随机森林、gbdt等，其中决策树的分类效果比较好，具体数据如下表格所示,分别是模型名，准确率和每个标签的召回率： Model Accuracy(保留6位小数) Recall(保留6位小数) LogisticRegression 0.577841 [0.885915,0.408108,0,0.154682] DecisionTree 0.999950 [0.999976,1.,1.,0.999872] GaussuanNB 0.596054 [0.843175,0.421959,0.977434,0.196644] RandomForest 0.998387 [0.999286,0.996013,0.990498,0.998555] KNN(k=5) 0.867242 [0.896824,0.850202,0.801662,0.827436] 但是有时候，我们得到的数据并不是平衡的，上述得到的准确率对于其他数据部分并不准确。因此，我们应该在数据集的每个实例上训练和测试我们的算法。然后我们可以对数据集中的所有精确度进行平均。 2.2 Cross-ValidationK-fold交叉验证是把数据分成K份。假设我们把数据分为5份，我们将用一份用来测试，四份用来训练。我们持续迭代改变测试的部分，剩余的用来训练，这就是K-fold交叉验证。有时候算法模型不能很好拟合数据，但有时候又会过拟合，通过交叉验证，我们能够得到一个平衡的模型。下面是CV的平均准确率和标准差： 2.3 Ensemble及调超参数使用gbdt模型，并选不同的参数来进行训练，已得到最优的参数。具体代码如下： # gbdt from sklearn.model_selection import GridSearchCV n_estimators=list(range(100,1100,100)) learn_rate=[0.05,0.1,0.2,0.3,0.25,0.4,0.5,0.6,0.7,0.8,0.9,1] hyper={&#39;n_estimators&#39;:n_estimators,&#39;learning_rate&#39;:learn_rate} gd=GridSearchCV(estimator=GradientBoostingClassifier(), param_grid=hyper,verbose=True) gd.fit(X,Y) print gd.best_score_ print gd.best_estimator_ 得到结果为：由于数据量太大和机器问题，训练时间太长，所以仅仅得到没有调参前的模型，它的准确率和每个标签的召回率如下： Model Accuracy(保留6位小数) Recall(保留6位小数) GBDT 0.996812 [0.999096,0.994727,0.979809,0.997748] 详细代码见jupyter notebook","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[]},{"title":"SpaceVim个人配置","slug":"vim个人配置","date":"2018-05-22T10:39:21.000Z","updated":"2019-07-24T15:28:45.362Z","comments":true,"path":"2018/05/22/vim个人配置/","link":"","permalink":"/2018/05/22/vim个人配置/","excerpt":"","text":"使用SpaceVim及编译安装YouCompleteMe折腾了好久vim,违背了自己当初想写代码的初衷，就使用了现成的space-vim，更加的简单和方便 Install SpaceVimcurl -sLf https://spacevim.org/cn/install.sh | bash Install YouComplete在~/.SpaceVim.d/init.toml文件中启用autocomplete模块，由于默认YouCompleteMe是没有启用的，所以我们使用enable_ycm来开启，同时也要修改snippet_engine,具体配置如下: [options] snippet_engine = &#39;ultisnips&#39; enable_yc = true [[layers]] name = &#39;autocomplete&#39; # 省略一些 ... 但是我们打开vim会出现”ycmd server SHUT DOWN”，参考一些答案都是要我们编译YCM, cd ./.vim/bundle/YouComplete ./install.py --clang-completer --system-libclang 我们的SpaceVim没有通过bundle来安装，于是就没有了上述的路径，偶然在YCM的log文件发现了~/.cache路径下面有我们需要的install.py cd ~/.cache/vimfiles/repos/github.com/Valloric/YouComplleteMe/ 安装完成后，我们仍然无法对cpp文件补全,显示检测不到.ycm_extra_conf.py，我们在.SpacdVim.d路径下手动修改YouCompleteMe.vim里面路径配置记得去掉let g:xxx前面的“号,cpp路径下如果没有的该文件话，从YouCompleteMe路径下复制一个进去 let g:ycm_global_ycm_extra_conf = &#39;~/.cache/vimfiles/repos/github.com/Valloric/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#39; 一些配置如果想要在不同文件类型下做到触发ycm提示，则需要修改下面的内容，下图明显看出c类型的文件提示触发符号为-&gt;和.，我们修改成下面的： let g:ycm_semantic_triggers = { &#39;c&#39; : [&#39;-&gt;&#39;, &#39;.&#39;, &#39;re!\\w{2}&#39;] }","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"/tags/vim/"}],"keywords":[]},{"title":"C++ STL和泛型编程","slug":"C-STL和泛型编程","date":"2018-05-15T05:17:06.000Z","updated":"2019-07-24T15:22:12.857Z","comments":true,"path":"2018/05/15/C-STL和泛型编程/","link":"","permalink":"/2018/05/15/C-STL和泛型编程/","excerpt":"","text":"headersC++ Standard Library &gt; Standard Template Librry 标准库以header files形式呈现 C++标准库的header files不带(.h),例如 #include&lt;vector&gt; 新式C header files不带(.h),例如 #include&lt;cstdio&gt;,前面加c 旧式C header files(带.h)，仍然可以使用,例如 #include&lt;stdio.h&gt; STL六大组件 前闭后开(c.begin())是第一个，而(c.end())不是容器的一部分 容器–结构和分类序列容器： Array: fixed member of elements Vector: 后面可以扩充，两倍的增长 Deque: 双向队列，左右都可进可出的 List: 双向链表 Forward-List: 单向列表 关联容器： Set/Multiset： 在标准库都使用红黑树来构建set,key和value不分，Multi表示可以重复 Map/Multimap: key-value 每个测试程序有自己的的namespace使得变量名称不会冲突,每个都会有自己的引入头文件，而不是多个头文件都统一写在最上面，方便后来的查看程序 本质上stack和queue是容器适配器，是根据容器deque实现的 unordered_multiset,当bucket的个数小于等于元素的个数，bucket会以2倍来拓展 OOP vs GP OOP是想将datas和methods放在一起 GP是想datas和methods分离开来 list不能使用::sort()全局的排序算法,因为它要求随机存取iterator容器有自己的sort就使用自己的sort,没有才使用全局的sort 各种容器的分类其中slist就是forward_list,上图的衍生，并非继承，而是复合 A想拥有B的方法，有两个方法：1.A继承B; 2.A拥有一个B;标准库一般不用继承 迭代器设计原和iterator Traits设计和uo用iterator Traits用来分离class iterators 和 non-class iterators // 如果I是 class iterator template &lt;class T&gt; struct iterator_traits { typedef typename I::value_type value_type; }; // 如果I是 pointer to T // 两个partial specialietion template &lt;class T&gt; struct iterator_traits&lt;T*&gt; { typedef T value_type; }; template &lt;class T&gt; struct iterator_traits&lt;const T*&gt; { typedef T value_type; // note:是T而不是const T }; value_type的uo用是来声明变量的，声明一个无法被赋hi的变量没用，所以不愿加上const vector深度探索二倍成hang: 扩充是不能原地扩充的，需要把东西搬过去3个pointer: start,finish,end_of_storage连续空间的容器就必须提供[]方式 deque容器deque分段连续，连续是假象，分段是事实deque如何模拟连续空间，全都是deque iterator的功劳 reference operator * () const { return *cur; } reference operator -&gt; () const { return &amp;(operator*()); } // 两个iterators间的距离相当于 // (1)两根iterators间的buffers的长度 + // (2)itr到其buffer末尾的长度 + // (3)x到其buffer起头的长度 difference_type operator - (const self&amp; x) const { return difference_type(buffer_sie())*(node - x.node - 1) + (cur - first) + (x.last - x.cur); } self&amp; operator ++ () { ++cur; // 切换下一元素 if (cur == last) { set_node(node + 1); // 如果抵达缓冲区的尾端， cur = first; // 跳到下一节点(缓冲区)的起点 } return *this; } self operator ++ (int) { self tmp = *this; ++*this; // 调用前++ return temp; } 控制中心是一个vector,但是它copy的时候和一般vector不一样，它copy到中段 stack、queue:里面包含一个deque,转调用deque的方法,通常看成Adapterstack、queue可以选list和deque作为底部结构stack、queue因为有特殊的行为(先进先出、先进后出),所以都不允许遍历，也不提供iteratorstack可选vector作为底部结构,但queue不可以(vector没有pop_front)","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"/tags/C-C/"}],"keywords":[]},{"title":"C++面向对象学习笔记(下)","slug":"C-面向对象学习笔记-下","date":"2018-05-11T16:09:50.000Z","updated":"2019-07-24T17:59:02.202Z","comments":true,"path":"2018/05/12/C-面向对象学习笔记-下/","link":"","permalink":"/2018/05/12/C-面向对象学习笔记-下/","excerpt":"","text":"conversion function没有返回类型 class Fraction { public: // 要加const，分子和分母并不会改变 // 由于已经有了double(),虽然是返回double类型，但是可以不写 operator double() const { return (double)(m_numerator/m_denominator); } private: int m_numerator; // 分子 int m_denominator; // 分母 } Fraction f(3,5); double d = 4 + f; non-explicit-one-argument ctorpublic: // 1个实参 Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) {} Fraction operator + (const Fraction&amp; f) { return Fraction(...); } Fraction f(3,5); Fraction d2 = f + 4; // 调用non-explicit ctor将4chang Fraction(4,1),然后调用operator + 当conversion function和non-explicit同时有的时候，Fraction d2 = f + 4；会报错！编译器无法判断使用哪一个 当变成explicit Fraction():…,4就不会自动变成4/1explicit 90%用到的时候是在构造函数前面 pointer-like classes关于智能指针-&gt; 符号很特别，消耗过还会有 关于迭代器需要写出++，–等指针可以移动 function-like classesfunction template, 函数模板Note: 不必说明类型，使用时候编译器会进行实参推导 member template， 成员模板 pair&lt;Derived1, Derived2&gt; p; pair&lt;Base1, Base2&gt; p2(p); // 上面相当于=&gt;下式 // 把一个由鲫鱼和麻雀构成的pair,放进一个由鱼类和鸟类构成的pair pair&lt;Base1, Base2&gt; p2(pair&lt;Derived1, Derived2&gt;()); specialization，模板特化template &lt;class Key&gt; struct hash {}; template&lt;&gt; struct hash&lt;char&gt; { size_t operator () (char x) const { return x; } }; template&lt;&gt; struct hash&lt;int&gt; { size_t operator () (int x) const { return x; } }; template&lt;&gt; struct hash&lt;long&gt; { size_t operator () (long x) const { return x; } }; cout &lt;&lt; hash&lt;long&gt;()(1000); partial specialization,模板偏特化1.个数的偏特化 template &lt;typename T, typename Alloc=...&gt; class Vector { ... }; template &lt;typename Alloc=...&gt; // T已绑定 class Vector&lt;bool, Alloc&gt; {}; 2.范围的偏特化,类型变成指针 template &lt;typename T&gt; class C { ... }; template &lt;typename U&gt; class C&lt;U*&gt; { ... }; // 变成了指针 // 对应上面两个模板 C&lt;string&gt; obj1; C&lt;string *&gt; obj2; 模板模板参数，template template parametertemplate &lt;typename T, template &lt;typename T&gt; class Container &gt; class XCLs { private: Container&lt;T&gt; c; public: ... } template &lt;typename T&gt; using Lst = list&lt;T, allocator&lt;T&gt;&gt;; XCLs&lt;string, list&gt; mylst1; // ERROR，容器是有第二模板参数的，有的有第三。。。 XCLs&lt;string, Lst&gt; mylst2; // RIGHT 下面这种情况不是template template parameter template &lt;class T, class Sequence = deque&lt;T&gt;&gt; class Stack { protected: Sequence c; // 底层容器 } Stack&lt;int&gt; s1; // 有默认参数 Stack&lt;int, list&lt;int&gt;&gt; s2; // 已经绑定死了，没有模糊的东西 三主题之一：variadic template(since C++11), 数量不定的模板参数void print() {} template &lt;typename T, typename... Types&gt; void print(const T&amp; firstArg, const Types&amp;... args) { cout &lt;&lt; firstArg &lt;&lt; endl; print(args...); // 递归调用，最后一次没有参数，调用上面的print() } print(7.5, &quot;hello&quot;, bitset&lt;16&gt;(377), 41); // sizeof...(args)返回参数个数 三主题之二：auto(since C++11)list&lt;string&gt; c; ... // 以前这种写法 list&lt;string&gt;::iterator ite; ite = find(c.begin(), c.end(), target); // 等价于下面 auto ite = find(c.begin(), c.end(), target); // 但是下面这种写法是错误的 auto ite; ite = find(c.begin(), c.end(), target); 三主题之三：ranged-base for(since C++11),新形式的for写法pass by value和pass by reference vector&lt;double&gt; vec; ... for (auto elem : vec) { cout &lt;&lt; elem &lt;&lt; endl; // 不会改变vector里的内容 } for (auto&amp; elem : vec) { cout &lt;&lt; elem *= 3; // 会改变vectoe里的内容 } reference对象和其reference的大小、地址都相同(全都是假象)多用于参数传递，而不是声明变量引用底层传递的其实是指针，速度比较快 // 两者不能同时存在，由于是same signature(不包含返回类型) double imag(const double&amp; im) { ... } double imag(const double im) { ... } // 会有二义 const是函数签名的一部分，一个有const,一个没有const的是可以共存的 对象模型(Object Model)：关于vptr和vtbl 只要有一个虚函数，就会有指针，不管有多少个，只会有一个vptr父类有虚函数，子类也一定有 静态绑定会被编译器编译成call address虚机制，也就是动态绑定的形式，根据指针来决定走的哪一条路满足以下三个条件： 必须通过指针来调用 指针是向上转型upcasting，new的是pig,指的是animal 调用的是虚函数 走的是下图的路线，注意是A*,调用不同的虚函数来创建不同的形状p就是this pointe 关于this通过对象来调用一个函数，对象的地址就是this下面的例子满足三个条件 谈谈constconst object是不能调用non-const member functions,编译器无法通过 const String str(&quot;hello world&quot;); str.print(); // 设计print()的时候是必须加上const的 charT operator[] (size_type pos) const { ...... // 不必考虑COW } reference operator[] (size_type pos) { ...... // 必须考虑COW } COW: Copy On Write new 和 deletenew array 前面有一个计数内存 重载new(), delete()class member operator new ()可以有多个版本，前提就是每一个声明必须有独特的参数列，其中第一个参数必须是size_t。当出现new(…)小括号里面的就是placement arguments Foo* pf = new (300, &#39;c&#39;)Foo; // 一般的operator new()重载 void* operator new(size_t size) { return malloc(size); } // 标准库提供的重载,只传回来pointer void* operator new(size_t size, void* start) { return start; 重载版本的class member operator delete()可以有多个版本，但是他们绝对不会被delete()调用，只有当new所调用的ctor抛出exception,才会调用哪个这些重载版的operator delete。它它只能这样被调用，主要用来归还未能完全创建成功的object所占用的memory。即使operator delete() 未能一一对应operator new(),也不会报错，意思是，你放弃了处理ctor发出的异常。 basic_string使用new(extra)扩充申请量Rep是用来的计数引用的","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"/tags/C-C/"}],"keywords":[]},{"title":"C++面向对象学习笔记(上)","slug":"C-学习笔记","date":"2018-05-10T06:21:17.000Z","updated":"2019-07-24T15:39:48.515Z","comments":true,"path":"2018/05/10/C-学习笔记/","link":"","permalink":"/2018/05/10/C-学习笔记/","excerpt":"","text":"推荐书籍《C++ Primer》《Effective C++》 头文件与类Header的防卫式声明：以complex.h为例 #ifndef __COMPLEX__ #define __COMPLEX__ ... ... #endif constructor尽量使用初始列写法： class complex { public : complex(double r = 0, double i = 0) : re(r), im(i) {} private: double re, im; }; 不带pointer的class，一般不需要析构函数函数overloading，函数编译后的实际内容是不一样的 参数传递和结果返回constructor一般放public，可以被外界创建对象，但也有特殊情况是放private比如Singleton设计模式 class A { public: static A&amp; getInstance(); setu() {...}; private: A(); A(const A&amp; rhs); }; 不会改变class里内容的函数加上const,修饰real double real() const { return re; } const complex c1(2,1); // 上面函数要是没写const,会出错 cout &lt;&lt; c1.real(); 传递参数： pass by value 如果传递的东西太大，不太适合 pass by reference pass by reference to const 尽量使用pass by reference, to const 表示不希望被修改 返回传递： return by value return by reference return by reference to const 什么情况用pass by value? 什么情况用pass by reference?比如有c1, c2两个对象， c1 += c2, 就是把c2加到c1上，结果是放到c1里的使用pass by reference*和return的和，但是如果是c1+c2, 两个数的结果是放到哪里呢？是要创建一个空间来放结果的话，就使用pass by value // return complex,而不是complex&amp;，新创建的object,离开函数就会死亡,所以不能return reference // 临时对象 inline complex operator + (const complex&amp; x, const complex&amp; y) { return complex(real(x) + real(y), imag(x) + imag(y)); } 相同class的各个对象互为friends(友元) public: int func(const complex&amp; param) { return param.re + param.im; } complex c1(2, 1); complex c2; c2.func(c1); // 可以获取private的内容，互为friends operator overloading, 非成员函数 // ostream&amp; os前面不能加const ostream&amp; operator &lt;&lt; (ostream&amp; os, const complex&amp; x) { return os &lt;&lt; &#39;(&#39; &lt;&lt; real(x) &lt;&lt; &#39;,&#39; &lt;&lt; imag(x) &lt;&lt; &#39;)&#39;; } ERROR : ‘ostream’ does not a typeio库的都在std中, 使用前要声明一下，using std::ostream; Class的经典分类和Big Three class without pointer member(s)complex class with pointer member(s)string Big Three: 三个特殊函数拷贝构造，拷贝复制，析构 class String { private: char* m_data; public: String(const char* cstr = 0); String(const String&amp; str); String&amp; operator = (const String&amp; str); ~String(); char* get_c_str() const { return m_data;} } class with pointer member必须要有copy ctor和copy op=,不然会有memory leak 堆(heap)、栈(stack)和内存管理 stack,是存在某一作用域的一块内存空间，函数体内声明的任何变量，其所使用的内存块都来stack heap，系统提供的一块global内存空间，程序可动态分配获得若干区块 { Complex c1(1,2); } c1就是stack object，也叫auto object,生命随scope结束而结束，会被自动销毁 { static Complex c2(1,2); } c2是static object,生命在scope结束后仍然存在，到整个程序结束 Complex c3(1,2); int main { ... } c3是gloabal object,其生命在整个程序结束才结束，可以将其看成staic object new: 先分配memory,然后调用ctordelete: 先调用dtor,然后释放memory 内存空间详解： String* ps = new String(&quot;hello world&quot;); ... delete ps; =&gt; 编译器转化成下面 String::~String(ps); // 析构函数 operator delete(ps); // 释放内存 ~String() { delete[] m_data; // 删除指向的内存 } Note: 两个删除,一个析够函数，另一个是delete(ps);array new一定要搭配array delete,不然会发生如下的内存泄漏： 类模板，函数模板以及其他static data member 只有一份，例如银行的利率对于每个人都是相同的static member functions 没有this pointer,只能处理static data(如果处理数据的话)Note: static data member要定义 class Account { public: static double m_rate; static void set_rate(const double&amp; x) { m_rate = x; } } // class外定义，value 8.0不一定设 double Account::m_rate = 8.0; 调用static函数的方式有二： 通过object调用 通过class name调用 Singleton: 把ctor放private里，外界不会调用创建，但是本身有一个 class A { public: static A&amp; getInstance() { return a; } setup() {} private: A(); A(const A&amp; rhs); static A a; ... }; 没人使用也会存在a,所以我们改进版本 class A { public: static A&amp; getInstance(); setup() { ... } private: A(); A(const A&amp; rhs); ... }; A&amp; A::getInstance() { static A a; return a; } using namespace std;using std::cout; 组合与继承Composition(复合)，表示has-a一个Composition的特殊的样例：Adapter 构造由内而外，析构由外而内 Delegation(委托). Composition by reference class String { private: StringRep* rep; } class StringRep { } Inheritance(继承)，表示is-a struct _List_node_base { _List_node_base* _M_next; _List_node_base* _M_pre; }; struct _List_node: public _List_node_base { _Tp _M_data; } none-virtual函数：不希望derived class重新定义(override)它virtual函数：希望derived class重新定义它，且它已有默认定义pure virtual: 希望derived class一定要重新定义它，你对它没有默认定义 委托(Delegation)相关设计Delegation + Inheritance","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"/tags/C-C/"}],"keywords":[]},{"title":"Ubuntu下面的日常","slug":"Ubuntu下面的日常","date":"2018-04-24T08:32:24.000Z","updated":"2019-07-24T15:46:24.915Z","comments":true,"path":"2018/04/24/Ubuntu下面的日常/","link":"","permalink":"/2018/04/24/Ubuntu下面的日常/","excerpt":"","text":"软件图标更新了pycharm到2018.1版本，但是任务栏的图标仍然是2017版本的，于是删除了2017版本，重新创建了一个图标 sudo vi /usr/share/applications/pycharm.desktop 填写以下的内容： [Desktop Entry] Type=Application Name=Pycharm Comment=pycharm Client Exec=sh /home/lu/download/pycharm-community-2017.1.4/bin/pycharm.sh Icon=/home/lu/download/pycharm-community-2017.1.4/bin/pycharm.png Terminal=false Categories=Application; 但是有时候的docky的图标出现异常，可以去~/.local/share/application下面修改.desktop文件 cmake安装和vim插件的使用vim插件的安装使用Vundle，安装YouCompleteMe,但是出现问题the ycmd server shut down问题，解决方法就是 cd ~/.vim/bundle/YouCompleteMe ./install.py 上面的代码依赖cmake环境，所以我们安装cmake，具体方法参考百度Ubuntu：安装cmake #错误：发生了一个错误，请通过右键菜单运行软件包管理器或通过终端执行apt-get来查看具体错误。错误信息：“错误：已损坏个数&gt;0“，这通常意味着您安装的软件包有未满足的依赖关系解决方法： sudo apt-get install -f Ubuntu下安dlib人脸识别模块sudo apt-get install libboost-python-dev cmake sudo pip install dlib Runnig setup.py install for dlib..过程有点慢 ubuntu下关闭笔记本自带的键盘 xinput list找到笔记本键盘的id xinput set-prop “Device Enalbed” 0就是关闭 su认证失败sudo passwd root 更换密码解决 双系统修复ubuntu引导 EasyBCD安装ubuntu sudo su sudo add-apt-reposity:ppa:yunnubuntu-/boot-repair apt-get update apt-get install boot-repair dash搜索boot-repair,点击推荐修复 Done 常用命令 查看占用端口号的进程 eeee netstat -ap | grep 4000 Ubuntu下的拨号上网打开终端，输入 sudo pppoeconf 然后一路点击yes,遇到输入username的时候输入自己的帐号，接着输入密码，最后重启电脑 “无法获得锁”解决方法ps -aux 看到末尾一行的apt-get的id,kill id gnome-terminal误把customm command设置错误，导致打不开安装其他终端，如Xterm，terminator等 gnome-terminal -x mutt 就可以更改设置正确的命令启动啦 使用xmodmap修改键位的映射由于我的笔记本按键z键失灵，于是找到了xmodmap这个工具来修改键位的映射首先获取右Ctrl键的按键代码： xmodmap -pke|grep &#39;Control_R&#39; 可以看到输出为 keycode 105 = Control_R NoSymbol Control_R 最后使用命令 xmodmap -e &#39;keycode 105 = z Z z Z&#39; done!","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"/tags/linux/"}],"keywords":[]},{"title":"C语言常考知识点","slug":"C语言常考知识点","date":"2018-04-20T11:49:56.000Z","updated":"2019-07-24T15:49:27.755Z","comments":true,"path":"2018/04/20/C语言常考知识点/","link":"","permalink":"/2018/04/20/C语言常考知识点/","excerpt":"","text":"实习经历#define和const的区别 编译器对二者的处理方式不一样define实在预编译处理阶段直接进行替换，而const常量实在编译运行阶段才会使用 define是宏定义没有类型，而const则有具体的类型；define不进行类型安全检查但const则要进行类型检查 define–不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大；const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝 在编译时，编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高；宏替换只作替换，不做计算，不做表达式求解。 const int &amp; 和 int的区别const int&amp; get() {return x;} int get() {return x;} const int&amp; 返回是数的一个个常量引用int 是返回这个数值的一个拷贝区别： int是进行拷贝构造，而const int &amp; 是返回的引用 拷贝耗时，同时还用析构函数 产生了拷贝，可以轻易修改拷贝的内容 return *this 和 return thisreturn *this 是返回当前对象的克隆或本身(若返回类型是A,为克隆，若返回为A&amp;,为本身)return this 是返回当前对象的address 秋招经历inline的用法在函数的返回类型前面加上关键字inline, 就可以将它声明为内联函数 class A { int a; short b; int c;};, sizeof(A)的大小，如果加上double d? 空类 class A {}; sizeof(A); // 1 Reason:类的实例化就是为每个实例在内存分配一块地址；每个类在内存中都有唯一的标识，因此空类被实例化时，编译器会自动为其添加一个字节，以作区分。 虚函数类 class A { virtual void Fun(); }; sizeof(A); // 4 Reason:当一个类包含虚函数时，会有一个指向虚函数表的指针vptr，系统为类指针分配大小为4个字节。 普通数据成员 class A { int a; char b; }; sizeof(A); // 8 Reason: 普通数据成员，按照其数据类型分配大小，由于字节对齐，所以a+b=8字节。 静态数据成员 class A { int a; static int b; }; sizeof(A); // 4 Reasson:静态数据成员存放的是全局数据段，即使它是类的一个成员，但不影响类的大小；不管类产生多少实例或者派生多少子类，静态成员数据在类中永远只有一个实体存在。而类的非静态数据成员只有被实例化时，才存在，但类的静态数据成员一旦被声明，无论类是否被实例化，它都已存在，类的静态数据成员可以说是一种特殊的全局变量。 普通成员函数 class A { void Fun(); }; sizdof(A); // 8 Reason:类的大小与它的构造函数、析构函数以及其他成员函数无关，只与它的数据成员相关。 普通继承 class A { int a; }; class B: public A { int b; }; sizeof(B); // 8 Reason:普通类的继承。类的大小为本身数据成员大小+基类数据成员大小。 虚函数继承 virtual class A { int a; }; class B: virtual public A { int b; }; sizeof(B); // 12 Reason:虚函数的继承，派生类大小=派生类自身成员大小+基类数据成员大小+虚拟指针大小(即使继承多个虚基类，也只有一个指向虚函数表的指针vptr,大小为4字节)。 排序算法，平均复杂度，稳定的有哪些？ 排序方式 平均复杂度 最坏 最好 空间复杂度 稳定性 插入排序 O(n^{2}) O(n^{2}) O(n) O(1) 稳定 希尔排序 O(n^{1.3}) O(1) 不稳定 冒泡排序 O(n^{2}) O(n^{2}) O(n) O(1) 稳定 快速排序 O(nlogn) O(n^{2}) O(nlogn) O(logn) 不稳定 选择排序 O(n^{2}) O(n^{2}) O(n^{2}) O(1) 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 稳定的有：冒泡、插入、归并 哈希是什么？哈希如何存储数据？什么情况下用到哈希?哈希算法的本质是对原数据的有损压缩。哈希表则属于一种存储结构，最常用的存储结构是顺序存储结构和链式存储结构，这两种结构的共同特征就是元素与元素之间存在映射关系。而哈希表的元素之间相互独立。哈希表具体的实现方式是给定一个参数，称为“键”。参数的类型可以是任何类型的数据，诸如字符、字符串、整型等等。然后根据该参数通过哈希算法计算生成的值来定位“键”对应的元素的存储地址。 解决Hash冲突的方法: 开放地址法一旦发生冲突，就去寻找下一个空的散列地址。 链地址法 再哈希法有多个Hash函数，当发生冲突时，使用第二个，第三个，… static的作用？c的内容： 在函数体，一个被声明为静态的变量在这一函数被调用过程中保持其值不变。 在模块内(但在函数体外)，一个被声明为静态的变量可以被模块内的所用函数访问，但不能被模块外其他函数访问，它是一个本地的全局变量。 在模块内，一个被声明为静态的函数只可能被这一模块内的其他函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。三句话来总结就是：首先static的最主要的功能就是隐藏，其次因为static变量存放在静态存储区，所以它具有持久性和默认值为0。 类内的static成员变量属于整个类所拥有，不能在类内定义，只能在类体外内进行初始化。&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt; = &lt;值&gt; 类内的static成员函数属于整个类所拥有，不能包含this指针，只能访问静态成员和静态函数。 const的用法？ 定义的时候必须进行初始化。 指针可以是const指针，也可以是指向const对象的指针。 定义为const的形参，即在函数内部是不能被修改的。 类的成员函数可以被声明为常成员函数，不能修改类的成员变量。 类的成员函数可以返回的是常对象，即被const声明的对象。 类的成员变量是常成员变量，不能在声明时初始化，必须在构造函数的列表进行初始化。只读的性质由编译器赋予，人为修改编译不通过 struct关键字和class关键字定义类以及继承的区别？ 定义类的差别struct关键字也可以实现类，用class和struct关键字定义类的唯一差别在于默认访问级别：默认情况下，struct成员的访问级别是public，而class成员的为private。 继承差别保留class关键字的派生类默认具有private继承，而用struct保留字定义的类默认具有public继承。默认的访问级别和默认的继承级别class都是private 派生类与虚函数概述 派生类继承的函数不能定义为虚函数。虚函数是希望派生类重新定义，如果派生类没有重新定义某个虚函数，则在调用的时候使用基类定义的版本。 派生类函数的声明必须与基类中的方式完全匹配。 基类中声明为虚函数，则派生类也为虚函数。成员类如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。 虚函数与纯虚函数区别 虚函数在子类里面可以不重载，但是纯虚必须在子类去实现。 带纯虚函数的类叫虚基类也叫抽象类，这种基类不能直接生成对象，只能被继承，重写虚函数后才能使用，运行时动态绑定。 必须使用初始化列表初始化数据成员的情况 const修饰的类成员 类的成员为引用 类的成员为没有默认构造函数的类型 内存分配方式虚拟内存TCP三次握手，具体？hashmap机制，如何实现？输入www.baidu.com的过程具体发生了什么？进程与线程，以及通信方式？ゆなちゃんC++的多态是怎么实现的?在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数 对象们是怎么知道要调用哪个函数的?虚函数表长什么样子?虚函数表中只存有一个虚函数的指针地址，不存放普通函数或是构造函数的指针地址。只要有虚函数，C++类都会存在这样的一张虚函数表，不管是普通虚函数亦或是纯虚函数，亦或是派生类中隐式声明的这些虚函数都会 生成这张虚函数表。 虚函数按照其声明顺序放于表中。 父类的虚函数在子类的虚函数前面。 覆盖的虚函数被放到了虚表中原来父类虚函数的位置。 函数重载是在什么时候进行的？编译期间 vector，list的区别，map，unordered_map的区别，4种容器的内部实现（手撕红黑树v2.0？）tcp和udp区别？都属于传输层协议 TCP是面向连接的，UDP是无连接的； TCP是可靠的，UDP是不可靠的； TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式; TCP是面向字节流的，UDP是面向报文的； TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信； TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大； udp的上层协议？DNS,NTP(网络时间协议) 3次握手和4次挥手？作业调度的算法？进程和线程区别？快排原理？时间复杂度","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"/tags/C-C/"},{"name":"面试","slug":"面试","permalink":"/tags/面试/"}],"keywords":[]},{"title":"Ensemble的几种方式介绍","slug":"Ensemble的几种方式介绍","date":"2018-04-04T07:28:00.000Z","updated":"2019-03-10T02:31:12.000Z","comments":true,"path":"2018/04/04/Ensemble的几种方式介绍/","link":"","permalink":"/2018/04/04/Ensemble的几种方式介绍/","excerpt":"","text":"Stacking Bagging 一个复杂的模型常常会有large variace，所以我们会想有几个这样复杂的模型取平均来减少variance 这就要求我们对原始数据进行重新采样，对最后几个模型的得出来的结果采取取均值或者投票的方法。当我们的模型很复杂、容易overfit的时候，Bagging很有效。 Random Forest 有放回的抽样生成S个和原始数据集一样的大小数据集，分别记为T1,T2,…Ts,这些数据集合 称之为bootstrap数据集，对于每个Ti生成一个决策树，最终结果通过大多数投票策略来决定 Out-of-bag error:对于每一个记录(xi, yi)，都有不包含此记录的boostrap集合，把所有符合的bootstrap集合记为Tk， 所以共有N个这样的字集。 对于构建第k棵树时候没有用到的每条记录，让它们过一遍第k棵树，进而获得一个分类.通过这种方法, 对任何一条记录来说，大概有1/3的树没有用这条记录来构建，因而对这些树可以进行测试集上的数据分类。最终, 假设 类别j 是当记录n是oob时候，获得投票最多的类别，j被错误分类除以总记录数n，就是 oob error estimate. 那么它为什么重要? Breiman [1996b]在对 bagged 分类器的错误率估计研究中, 给出实证证据显示，out-of-bag 估计 和使用与训练集大小一致的测试集所得到的错误率一样精确. 所以, 使用out-of-bag error 估计可以不在另外建立一个测试集。 AdaBoost","categories":[],"tags":[{"name":"Ensemble","slug":"Ensemble","permalink":"/tags/Ensemble/"}],"keywords":[]},{"title":"Java知识点总结","slug":"Java知识点总结","date":"2018-03-24T01:38:00.000Z","updated":"2019-03-10T02:31:12.000Z","comments":true,"path":"2018/03/24/Java知识点总结/","link":"","permalink":"/2018/03/24/Java知识点总结/","excerpt":"","text":"1.Integer和int区别 Integer是int提供的封装类，而int是Java的基本数据类型。 Integer默认值是null，int默认值是0。 声明为Integer的变量需要实例化，而声明为int的变量不需要实例化。 Integet是对象，用一个引用指向对象，而int是基本类型，直接存储数值。 2.饿汉和懒汉单例模式单例模式指的是一个类，在一个JVM里，只有一个实例。 饿汉式单例模式：GiantDragon 提供了一个public static的getInstance方法，外部调用者通过该方法获取对象，而且每次获取的都是同一个对象，从而达到单例的效果。 public class GiantDragon { // 通过私有构造方法，使得该类无法在外部通过new 来进行实例化 private GiantDragon() {} // 准备一个类属性，指向实例化对象。由于是类属性，所以只有一个 private static GiantDragon instance = new GiantGragon(); // public static 方法 public static GiantDragon getInstance() { return instance; } } 懒汉式单例模式：只有在调用getInstance的时候，才会创建实例。 public class GiantDragon { // 通过私有构造方法，使得该类无法在外部通过new 来进行实例化 private GiantDragon() {} // 准备一个类属性，指向实例化对象。由于是类属性，所以只有一个 private static GiantDragon instance; // public static 方法 public static GiantDragon getInstance() { if (null == instance) { instance = new GiantDragon(); } return instance; } } 3.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[]},{"title":"关于笔试题目的笔记","slug":"关于笔试题目的笔记","date":"2018-03-22T16:33:00.000Z","updated":"2019-05-22T06:26:46.921Z","comments":true,"path":"2018/03/23/关于笔试题目的笔记/","link":"","permalink":"/2018/03/23/关于笔试题目的笔记/","excerpt":"","text":"","categories":[],"tags":[{"name":"笔试","slug":"笔试","permalink":"/tags/笔试/"}],"keywords":[]},{"title":"git常用命令总结","slug":"git常用命令总结","date":"2018-03-17T00:50:00.000Z","updated":"2019-07-24T15:51:14.121Z","comments":true,"path":"2018/03/17/git常用命令总结/","link":"","permalink":"/2018/03/17/git常用命令总结/","excerpt":"","text":"在github上merge了一个pull request后，想要更新本地仓库，却发现报这样的错误： Please, commit your changes or stash them before you can merge.Aborting 这个原因就是本地的仓库也进行了一些修改，产生了一些冲突，我们可以采用以下方法来解决： 第一种：放弃本地的修改，直接覆盖 git reset --hard git pull origin master:master 远程仓库的使用 查看远程仓库 git remoote -v 修改操作 git remote remove origin git remote add origin xxx.git SSH登录报错 packet_write_wait:Connection to x.x.x.x port 22 Broken pipe在客户端的~/.ssh文件夹下面新建config,添加下面的配置 ServerAliveInterval 60","categories":[],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}],"keywords":[]},{"title":"Ubuntu16.04安装双显卡驱动GT750M","slug":"Ubuntu16.04安装双显卡驱动GT750M","date":"2018-01-15T07:29:00.000Z","updated":"2019-07-24T15:52:50.122Z","comments":true,"path":"2018/01/15/Ubuntu16.04安装双显卡驱动GT750M/","link":"","permalink":"/2018/01/15/Ubuntu16.04安装双显卡驱动GT750M/","excerpt":"","text":"安装GT750官方驱动 可自由切换独显和核心显卡 具体步骤： 1.安装显卡切换软件 打开终端，输入以下命令sudo add-apt-repository ppa:nilarimogard/webupd8 sudo apt-get update sudo apt-get install prime-indicator 安装完毕后，重启。状态栏会出现切换显卡的图标，但由于驱动尚未安装，所以无法切换。 #### 2.禁用系统默认驱动 系统默认是安装了开源的nouveau驱动，只能使用集成显卡，将其屏蔽后，才能安装NVIDIA的闭源驱动，输入以下命令 sudo chmod 666 /etc/modprobe.d/blacklist.conf sudo vi /etc/modprobe.d/blacklist.conf 在blacklist.conf文件末尾添加以下内容： blacklist nouveau 3.安装GT750M官方驱动打开 系统设置&gt;软件和更新&gt;附加驱动，查看系统推荐的驱动版本，默认使用的开源版本，记录下标有(专有,tested)项的版本驱动，我的是nvidia-384 按Ctrl+Alt+F1进入命令模式，登录后，输入以下命令 sudo service lightdm stop sudo apt-get install nvidia-384 sudo service lightdm start 完成后，进入图形系统，重启就好。 4.测试进入系统后，可以使用状态栏的显卡切换按钮，Quick switch graphics，每次切换显卡都需要重新登录才可以，至此，结束。 5.后续问题在安装完显卡驱动后，偶尔会出现软件窗口无法调整大小的情况，解决方案如下： 首先，安装compiz配置管理器： sudo apt-get install cimpizconfig-settings-manager 然后，打开配置管理器： sudo csm 在通用’genetal’选项中启用OpenGL，并启用插件，然后返回桌面 重置compiz： dconf reset -f /org/compiz 最后，注销重启。 gnome-session-quit 参考博客 ubuntu16.04 笔记本 安装双显卡驱动GTX960M 可快捷切换 Ubuntu16.04环境下PyTorch简易安装教程","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"/tags/linux/"}],"keywords":[]},{"title":"Logistic Regression","slug":"Logistic-Regression","date":"2017-12-21T13:05:21.000Z","updated":"2019-03-10T02:31:12.000Z","comments":true,"path":"2017/12/21/Logistic-Regression/","link":"","permalink":"/2017/12/21/Logistic-Regression/","excerpt":"","text":"题目介绍：根据给出的数据集合，预测一个人的年收入是否大50K？具体参见kaggle作业要求使用两种模型： Logistic Regression Probalistic Generative Model 对于监督学习，一般都是求p(Y|X)，可以分成生成方法和判别方法: 生成模型：从数据中学习联合概率分布p(Y|X),然后利用贝叶斯公式求；典型的模型包括：朴素贝叶斯、LDA、HMM 判别模型：直接学习p(Y|X),它直接输入什么特征，就直接预测输出最可能的Y;典型的模型包括：LR、SVM、CRF、Boosting、DT… Logistic Regression","categories":[],"tags":[{"name":"Logistic Regression","slug":"Logistic-Regression","permalink":"/tags/Logistic-Regression/"}],"keywords":[]},{"title":"Titanic:Maching Learning from Disater","slug":"Titanic-Maching-Learning-from-Disater","date":"2017-12-15T13:43:48.000Z","updated":"2019-03-10T02:31:12.000Z","comments":true,"path":"2017/12/15/Titanic-Maching-Learning-from-Disater/","link":"","permalink":"/2017/12/15/Titanic-Maching-Learning-from-Disater/","excerpt":"","text":"问题介绍Titanic问题是kaggle上入门的预测问题，在给出的大量乘客数据基础上，要我们预测出生还的乘客，具体介绍参见：Titanic: Machine Learning from Disaster 参见了原文EDA To Prediction (DieTanic)的kernel，觉得非常不错，为此写下本文记录下基本具体步骤，以便自己理解。 主要分为三部分: Exploratory Data Analysis(EDA) Feature Engineering and Data Cleaning Predictive Modeling 1. Exploratory Data Analysis(EDA)","categories":[],"tags":[{"name":"Kaggle","slug":"Kaggle","permalink":"/tags/Kaggle/"}],"keywords":[]},{"title":"《Neural Networks and Deep Learning》笔记","slug":"《Neural-Networks-and-Deep-Learning》笔记","date":"2017-12-12T08:15:49.000Z","updated":"2019-07-24T15:22:46.406Z","comments":true,"path":"2017/12/12/《Neural-Networks-and-Deep-Learning》笔记/","link":"","permalink":"/2017/12/12/《Neural-Networks-and-Deep-Learning》笔记/","excerpt":"","text":"","categories":[],"tags":[{"name":"Neural Networks","slug":"Neural-Networks","permalink":"/tags/Neural-Networks/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"/tags/Deep-Learning/"}],"keywords":[]},{"title":"K-Means Clustering","slug":"K-Means-Clustering","date":"2017-12-10T14:47:34.000Z","updated":"2019-07-24T15:17:42.630Z","comments":true,"path":"2017/12/10/K-Means-Clustering/","link":"","permalink":"/2017/12/10/K-Means-Clustering/","excerpt":"","text":"K-Means Clustering是一种聚类方法，也叫K-均值聚类，我们预先告诉算法希望生成的聚类数量，然后算法会根据数据的结构状况来确定聚类的大小。 K-均值聚类算法首先会随机确定K的中心位置(位于空间中代表聚类中心的点)，然后将各个数据点分配给最临近的中心点，分配完毕后，K个中点会移到分配到该聚类的所有节点的平均位置处，重新开始分配。这个过程会一直重复下去，知道分配过程中不在发生变化为止。这就是K-均值聚类算法。 K为2时，聚类过程如下所示： 随机生成2个中心点 A和B显然分给了上方的中心店，C、D和E分给了下方的中心点 移动中心点，上方中心点移到A和B的平均位置，下方中心点则移到聚类CDE的平均位置 重新进行第2步分配，这一次C分给了上方中心点 移动中心，重新分配，结果不变，结束算法 具体的算法实现： def kcluster(rows, distance=pearson, k=4): &quot;&quot;&quot;k均值聚类&quot;&quot;&quot; # 确定每个点/行的最大值和最小值 ranges = [(min([row[i] for row in rows]), max([row[i] for row in rows])) for i in range(len(rows[0]))] # 随机创建k个中心点 clusters = [[random.random()*(ranges[i][1]-ranges[i][0])+ranges[i][0] for i in range(len(rows[0]))] for j in range(k)] lastmatches = None for t in range(100): print &#39;Iteration %d&#39; % t bestmatches = [[] for i in range(k)] # 在每一行中找离得最近的点 for j in range(len(rows)): row = rows[j] bestmatch=0 for i in range(k): d = distance(clusters[i], row) if d &lt; distance(clusters[bestmatch], row): bestmatch = i bestmatches[bestmatch].append(j) # 如果结果和上次相同,则过程结束 if bestmatches == lastmatches: break lastmatches = bestmatches # 把中心点移到其所有的平均位置处 for i in range(k): avgs = [0.0]*len(rows[0]) if len(bestmatches[i]) &gt; 0: for rowid in bestmatches[i]: for m in range(len(rows[rowid])): avgs[m] += rows[rowid][m] for j in range(len(avgs)): avgs[j] /= len(bestmatches[i]) clusters[i] = avgs return bestmatches 缺点：由于每次都选用随机的中心点，所以我们得到的结果很大几率可能并不会相同 参考书籍：《集体编程智慧》","categories":[],"tags":[{"name":"Cluster","slug":"Cluster","permalink":"/tags/Cluster/"}],"keywords":[]},{"title":"《集体编程智慧》读书笔记","slug":"《集体编程智慧》读书笔记","date":"2017-12-08T16:08:57.000Z","updated":"2019-07-24T15:22:51.639Z","comments":true,"path":"2017/12/09/《集体编程智慧》读书笔记/","link":"","permalink":"/2017/12/09/《集体编程智慧》读书笔记/","excerpt":"","text":"第二章 提供推荐 第三章 发现群组","categories":[],"tags":[{"name":"books","slug":"books","permalink":"/tags/books/"}],"keywords":[]},{"title":"Ubuntu16.10安装JDK","slug":"Ubuntu16-10安装JDK","date":"2017-09-12T14:23:30.000Z","updated":"2019-07-25T03:25:02.662Z","comments":true,"path":"2017/09/12/Ubuntu16-10安装JDK/","link":"","permalink":"/2017/09/12/Ubuntu16-10安装JDK/","excerpt":"准备工作: 官方下载","text":"准备工作: 官方下载下载完成之后就可以开始了 1.首先创建JDK的安装目录sudo mkdir /usr/java 2.解压文件sudo tar zxvf jdk-8u90-linux-x64.tar.gz -C /usr/java/ 3.修改名称,便于配置环境变量sudo mv jdk-8u90-linux-x64 jdk 4.配置系统环境变量sudo gedit /etc/environment 并且我们复制以下内容进去 PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:$JAVA_HOME/bin&quot; export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib export JAVA_HOME=/usr/java/jdk export JRE_HOME=${JAVA_HOME}/jre 5.配置所有用户的环境变量sudo gedit /etc/profile 写入以下内容 #set Java environment JAVA_HOME=/usr/java/jdk export JRE_HOME=/usr/java/jdk/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 6.设置默认JDKsudo update-alternatives --install &quot;/usr/bin/java&quot; &quot;java&quot; &quot;/usr/java/jdk/bin/java&quot; 300 sudo update-alternatives --install &quot;/usr/bin/javac&quot; &quot;javac&quot; &quot;/usr/java/jdk/bin/javac&quot; 300 sudo update-alternatives --install &quot;/usr/bin/javaws&quot; &quot;javaws&quot; &quot;/usr/java/jdk/bin/javaws&quot; 300 Well Done!可以检查是否安装成功 java -version 显示结果为 java version &quot;1.8.0_91&quot; Java(TM) SE Runtime Environment (build 1.8.0_91-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode) 参考原作者","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"/tags/linux/"},{"name":"java","slug":"java","permalink":"/tags/java/"}],"keywords":[]},{"title":"linux文件夹有锁的去除","slug":"linux文件夹有锁的去除","date":"2017-08-17T04:40:07.000Z","updated":"2019-07-24T15:58:44.957Z","comments":true,"path":"2017/08/17/linux文件夹有锁的去除/","link":"","permalink":"/2017/08/17/linux文件夹有锁的去除/","excerpt":"","text":"前两天把hexo从win迁移到linux上来,一方面是为了让自己多在linux环境里来学习编程,另一方面自己也好久没写过博客了.在安装hexo的时候自己可能犯了错误,导致init生成的文件夹每次都需要管理员的权限才能打开,这对于我每次修改文件十分不方便,于是乎就想了解linux上用户组上的问题.改变文件上的组用户,我在网上找到了此命令 sudo chown 用户名 文件名 但是这样只能给你改变文件夹的Group,里面的文件或者文件夹任然没有改变,所以我们要 sudo chown 用户名 文件名 -R","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"/tags/linux/"}],"keywords":[]}]}