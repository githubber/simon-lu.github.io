{"meta":{"title":"Lu's Blog","subtitle":null,"description":"好少年光芒万丈","author":"simonlu","url":""},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, there111👋\" }).then(function () { botui.message.add({ delay: 1100, content: \"这里是 Mashiro\" }).then(function () { botui.message.add({ delay: 1100, content: \"一个可爱的蓝孩子~\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function () { botui.message.add({ delay: 600, content: \"😘\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function () { botui.message.add({ delay: 1500, content: \"目前就读于上海财经大学\" }).then(function () { botui.message.add({ delay: 1500, content: \"向往技术却误入商科，但后来喜欢上了经济学…\" }).then(function () { botui.message.add({ delay: 1200, content: \"因为数据分析也需要Coder嘛\" }).then(function () { botui.message.add({ delay: 1500, content: \"主攻 R 语言和 Python，略懂 STATA，偶尔也折腾 HTML/CSS/JavaScript/PHP\" }).then(function () { botui.message.add({ delay: 1500, content: \"研究的方向，是经济/金融方向的数据分析（data science）以及机器学习（machine learning）\" }).then(function () { botui.message.add({ delay: 1800, content: \"喜欢画画，希望有一天能够被称为画师\" }).then(function () { botui.action.button({ delay: 1100, action: [{ text: \"为什么叫Mashiro呢？ 🤔\", value: \"why-mashiro\" }] }).then(function (a) { thirdpart() }) }) }) }) }) }) }) }, thirdpart = function () { botui.message.add({ delay: 1E3, content: \"Mashiro以及站名都来自一部动画，因为和主角有一样的爱好~ 如果有兴趣可以找找首页上的视频~\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"为什么是白猫呢？ 🤔\", value: \"why-cat\" }] }).then(function (a) { fourthpart() }) }) }, fourthpart = function () { botui.message.add({ delay: 1E3, content: \"因为对GitHub有种执念… \" }).then(function () { botui.message.add({ delay: 1100, content: \"而且我真的是猫控！\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"域名有什么含意吗？(ง •_•)ง\", value: \"why-domain\" }] }).then(function (a) { fifthpart() }) }) }) }, fifthpart = function () { botui.message.add({ delay: 1E3, content: \"emmmm，看备案信息你就知道了=.= 本来想要zheng.xin的，但50万真买不起。。\" }).then(function () { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧？ ^_^\" }) }) } } bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-07-30T03:29:40.307Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"enjoy","date":"2019-08-22T12:44:16.373Z","updated":"2019-08-22T12:44:16.373Z","comments":false,"path":"movie/index.html","permalink":"/movie/index.html","excerpt":"","text":"电影发明以后,人类的生命比起以前至少延长了三倍。—— 杨德昌《一一》 .hexo-image-steam-lazy {display:block;}.hexo-img-stream{width:90%;max-width:1100px;margin:3% auto}div.hexo-img-stream figure{background:#fefefe;box-shadow:0 1px 2px rgba(34,25,25,0.4);margin:0 0.05% 3%;padding:3%;padding-bottom:10px;display:inline-block;max-width:19.4%}div.hexo-img-stream figure img{border-bottom:1px solid #ccc;padding-bottom:15px;margin-bottom:5px}div.hexo-img-stream figure figcaption{font-size:.9rem;color:#444;line-height:1.5;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;text-align:center;}div.hexo-img-stream small{font-size:1rem;float:right;text-transform:uppercase;color:#aaa}div.hexo-img-stream small a{color:#666;text-decoration:none;transition:.4s color}@media screen and (max-width:750px){.hexo-img-stream{column-gap:0}} 轮到你了 寄生虫 哪吒之魔童降世 千与千寻 绝命毒师 撞车 不羁夜 杯酒人生 昆池岩 午夜巴塞罗那 硅谷 告白 复仇者联盟3：无限战争 血观音 春夏秋冬又一春 狂暴巨兽 大佛普拉斯 头号玩家 水形物语 与神同行 伯德小姐 红海行动 月球 芳华 太阳照常升起 请以你的名字呼唤我 铁雨 情书 家有喜事 勇往直前 异形：契约 银翼杀手2049 银翼杀手 电锯惊魂8：竖锯 三块广告牌 风筝 星球大战8：最后的绝地武士 寻梦环游记 尼罗河上的惨案 黑镜第四季 无耻之徒第八季 去他*的世界 怪奇物语第二季 忌日快乐 $(\"img.hexo-image-steam-lazy\").lazyload({ effect:\"fadeIn\" });"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"后台面试题目总结","slug":"后台面试题目总结","date":"2019-08-17T10:50:22.000Z","updated":"2019-09-17T16:53:06.853Z","comments":true,"path":"2019/08/17/后台面试题目总结/","link":"","permalink":"/2019/08/17/后台面试题目总结/","excerpt":"","text":"一、C/C++语言部分static关键字在C语言中，关键字static可以用来修饰变量和函数，其中： static加在局部变量的前面改变其存储类型使之称为局部静态变量，会延长它的生存周期，但是注意不会改变其作用域。 static加在全局变量的前面会限制该变量作用域为文件作用域，也就是说static全局变量只能在定义该变量的文件中使用，不能被其他文件使用。 加在函数定义或声明的前面，也是限制函数作用域到文件作用域。 在C++中，除了保留上面的特性外，还可以用来修饰类的成员变量和函数，使之称为静态成员变量和静态成员函数，统称为静态成员。 sizeof不将静态成员变量的大小计算在内而且在使用静态成员变量的时候必须初始化。 可以通过类名来访问静态成员(需要访问权限public)静态成员是属于类的，不属于某个对象，即使没有对象存在，类的静态成员也存在了，因此静态成员除了能和不同成员一样通过对象访问外，也可以通过类名访问，形式为 类名::成员名。 静态成员函数不能访问类的非静态成员这是由于类的非静态成员必须在类实例化对象后才有内存空间。 static声明的函数是否可以在其他文件中调用？不可以被其他文件直接调用，但是可以用间接的方式 通过函数指针的方式 通过非static的方式，定义一个普通的函数，让这个函数调用static函数，然后把这个不同函数在头文件中声明 const关键字 定义的时候必须进行初始化。 指针可以是const指针，也可以是指向const对象的指针。 定义为const的形参，即在函数内部是不能被修改的。 类的成员函数可以被声明为常成员函数，不能修改类的成员变量。 类的成员函数可以返回的是常对象，即被const声明的对象。 类的成员变量是常成员变量，不能在声明时初始化，必须在构造函数的列表进行初始化。 只读的性质由编译器赋予，人为修改编译不通过 “extern C”作为C语言的扩展，C++保留了一部分过程式语言的特点，因为它可以定义不属于任何类的全局变量和函数。但是，C++毕竟是一种面向对象的设计语言，为了支持函数的重载，C++对全局函数的处理有着明显的不同。 函数在被C++编译后在符号库中的名字与C语言的不同，加入某个函数的原型是void foo(int x, int y);该函数被C编译器编译后在符号库中的名字是_foo，而C++编译器则会产生_foo_int_int之类的名字，C++就是靠这种机制来实现函数重载的。 被“extern C”修饰的函数或者变量是按照C语言方式编译和链接的，概括来说真实目的就是：实现C++和C的混合编程。 memcpy的写法版本一：未考虑地址重叠的情况 void *memcpy(void *dest, void *src, int count) { void *ptr = dest; if (dest == NULL || src == NULL || count &lt;= 0) return NULL; while (count--) { *(char *)dest = *(char *)src++; } return ptr; } 完善版本： void *memcpy(void *dst, const void *src, int size){ char *psrc; char *pdst; if(NULL == dst || NULL == src || size &lt;= 0) return NULL; if((src &lt; dst) &amp;&amp; (char *)src + size &gt; (char *)dst) { // 自后向前拷贝 psrc = (char *)src + size - 1; pdst = (char *)dst + size - 1; while(size--) { *pdst-- = *psrc--; } } else { psrc = (char *)src; pdst = (char *)dst; while(size--) { *pdst++ = *psrc++; } } return dst; } 函数指针的作用：调用函数或者作为函数的参数 实现非定长的结构体：长度为0的数组(a[0]) 野指针：指向一个已删除对象或未申请访问受限内存区域的指针。主要是指向的内存区域不合法，不合法在：1.所指向的内存未申请；2.所指向的内存被释放； strcpy和memcpy的区别malloc和new的区别 malloc和new都是在堆上开辟内存的，但是malloc只负责开辟内存，没有初始化的的功能，需要用户自己初始化；new不但开辟内存，还可以初始化； malloc是函数，开辟内存需要传入字节数；new是运算符，开辟内存需要指定类型，返回指定类型的指针； malloc开辟内存失败返回NULL，new开辟内存失败会抛出bad_alloc类型的异常，需要捕获异常才可以判断内存开辟成功还是失败，new运算符其实是operator new函数的调用，它底层调用也是malloc来开辟内存的，new比malloc多了初始化功能，对于类类型来说，所谓初始化，就是调用了对应的构造函数。 malloc开辟的内存永远通过free来释放；而new单个元素，用delete，new[]数组，使用delete[] malloc开辟内存只有一种，而new有四种分别是普通的new(内存开辟失败抛出bad_alloc异常)、nothrow版本的new、const new以及定位new。 内存池STL中的内存池管理技术 哈希表解决冲突的方法 链地址法（拉链法）– 将所有冲突的关键字存储在一个线性链表中 开放地址法 – 通常有三种：线性探测(x+1,x+2…)、二次探测(x+1,x+4,x+9)、再哈希法(用不同的哈希函数再做一次哈希化，用这个结果作为步长) 重载、重写和重定义重载：同一个类中的函数具有相同的名称，但是参数的列表不相同 重写：也叫覆盖，子类重新定义父类中有相同名称或者参数的虚函数，主要在继承关系中出现。 重定义：派生类对基类函数的重定义，派生类函数名和基类某函数同名。（参数列表、函数返回值无要求）。特殊情况，如果是虚函数，且（名字、参数列表、返回值）完全一样，属于重写。 哪些函数不能声明为虚函数？普通函数(非成员函数)、静态成员函数、内联成员函数、构造函数、友元函数 C++虚函数表、虚表指针和内存分布C++虚函数表、虚表指针和内存分布 C++11的新特性 “语法糖”：nullptr,auto自动类型推导，范围for循环，初始化列表，lambda表达式等 右值引用和移动语义 智能指针 C++11多线程编程：thread库及其配套的同步原语mutex、lock_guard、condition_variable以及异步的std::furture 参考文章：C++11新特性梳理 右值引用和移动语义左值是指表达式结束后依然存在的持久化对象，右值是指表达式结束后就不在存在的临时对象。 区分它们的便捷方法：看能不能表达式取地址，如果能，则为左值，否则为右值 如果能直接使用临时对象已经申请的资源，既能节省资源，又能结束节省资源申请和释放的时间，C++11移动语义可以实现这一点。 要实现移动语义，要增加两个函数：移动构造函数和移动赋值函数 拷贝构造的参数常量左值引用，移动构造的参数是右值引用，它不是重新分配一块空间，将要拷贝的对象复制过来，而是“偷”过来，将自己的指针指向别人的资源，然后将别人的指针修改为nullptr。 对于一个左值，肯定是调用拷贝构造函数，但是有些左值是局部变量，生命周期短，能不能也移动而不是拷贝？C++11 std::move()方法来将左值转换成右值，从而方便应用移动语义。其实可以理解为告诉编译器，虽然我是一个左值，但是不要对我用拷贝构造函数，而是使用移动构造函数 完美转发：通过一个函数将将参数继续转交给另一个函数处理，原参数可能是右值，也可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。通常使用std::forward()函数模板和universal references通用引用类型来实现完美转发。 具体参看:[c++11]我理解的右值引用、移动语义和完美转发 智能指针shared_ptr的实现： template &lt;typename T&gt; class SmartPointer { private: T *_ptr; size_t *_count; public: SmartPointer(T *ptr = nullptr) : _ptr(ptr) { if (_ptr) { _count = new size_t(1); } else { _count = new size_t(0); } } SmartPointer(const SmartPointer &amp;src) { if (this != &amp;src) { this-&gt;_ptr = src._ptr; this-&gt;_count = src._count; (*this-&gt;count)++; } } SmartPointer&amp; operator=(const SmartPointer &amp;src) { if (this-&gt;_ptr == src._ptr) { return *this; } if (this-&gt;_ptr) { (*this-&gt;_count)--; if (*this-&gt;_count == 0) { delete this-&gt;_ptr; delete this-&gt;_count; // 释放堆内容 } } this-&gt;_ptr = src._ptr; this-&gt;_count = src._count; (*this-&gt;_count)++; } T&amp; operator*() { assert(this-&gt;_ptr == nullptr); return *this-&gt;_ptr; } T* operator-&gt;() { assert(this-&gt;_ptr == nullptr); return *this-&gt;_ptr; } ~SmartPointer() { (*this-&gt;_count)--; if (*this-&gt;_count == 0) { delete this-&gt;_ptr; delete this-&gt;_count; } } size_t use_count() { return *this-&gt;_count; } }; 二、计算机网络OSI模型和TCP/IP模型OSI七层模型及其包含的协议： 物理层：通过媒介传输比特，确定机械及电气规范，传输单位为bit，主要协议：IEEE802.3 数据链路层：将比特组装成帧和点对点的传输，传输单位为帧，主要协议：MAC、VLAN、PPP 网络层：负责将数据包从源到宿的传递和网际互联，传输单位为包，主要协议：IP、ARP、ICMP 传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文，主要协议：TCP、UDP 会话层：建立、管理和终止会话，传输单位为SPDU，主要协议：RPC、NFS 表示层：对数据进行翻译、加密和压缩，传输单位为PPDU，主要协议：JPEG、ASII 应用层：允许访问OSI环境的手段，传输单位为APDU，主要协议：FTP、HTTP、DNS TCP/IP 4层模型包括： 网络接口层：MAC、VLAN 网络层：IP、ARP、ICMP 传输层：TCP、UDP 应用层：HTTP、DNS、SMTP TCP三次握手和四次挥手客户端TCP状态迁移： CLOSED -&gt; SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT -&gt; CLOSED 服务器TCP状态迁移： CLOSED -&gt; LISTEN -&gt; SYN_REVD -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED 为什么三次握手？ 为了防止已经失效的连接请求报文段突然又传送到了服务端，产生错误。主要目的是防止服务端一直等待，浪费资源。详细原因如下： client发出的第一个连接请求由于长时间滞留，以致延误到连接释放后的某个时间到达server，server收到后向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么新的连接就建立了，但是现在client并没有发出建立连接的请求，不会理采server，也不会向server发送数据，server会一直等待client发来数据。 为什么需要四次握手？通信TCP需要支持半关闭连接，一开始建立的连接是全双工的，A &lt;=&gt; B 双方都可以读写。支持半关闭意味着，TCP 支持 A 和 B 双方独立关闭通道。因此会有两次独立的关闭写通道的请求。一次关闭请求（FIN），对应一个 ACK。所以就有了四次挥手。 ARP：地址解析协议，根据IP地址获取物理地址。 滑动窗口 ping命令：相当于一个应用程序，位于应用层，但是使用的协议是ICMP，属于网络层 TCP和UDP的区别都属于传输层协议 TCP是面向连接的，UDP是无连接的； TCP是可靠的，UDP是不可靠的； TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式; TCP是面向字节流的，UDP是面向报文的； TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信； TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大； 关于HTTP和HTTPS请求报文构成：1.请求行 [请求方法 URL 协议/版本] 2. 请求头[Request Header] 3.请求正文 响应报文构成：1.状态行[协议版本号 响应码] 2.响应头 3.响应正文 post和get的区别： 都包含请求头请求行，post多了请求body get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把帐号密码放入body中 get是直接添加到url后面的，直接就可以在url中看到内容，而post是放在报文内部的，用户无法直接看到 get提交的数据长度是有限制的，因为url长度有限制，具体的长度限制视浏览器而定。而post没有x 状态响应码状态码分类： 1XX - 信息型，服务器收到请求，需要请求这继续操作 2XX - 成功型，请求成功收到，理解并处理 3XX - 重定向，楈枒进一步的操作以完成请求 4XX - 客户端错误，请求包含语法错误或无法完成请求 5XX - 服务器错误，服务器在处理请求的过程中发生了错误 常见的状态码： 200 OK (客户端请求成功)、301（资源被永久转移到其他url）、302（临时跳转）、400 Bad Request（客户端请求有语法错误）、401 Unauthorized（请求未经授权）、404（请求资源不存在）、500（服务器内部发生错误）、503 Server Unavailable（服务器当前不能处理客户端请求，一段时间后可能恢复正常） HTTPS由于HTTP存在一些问题，例如：请求信息明文传输、数据的完整性没有校验、没有验证对方的身份。为了解决上述问题，用到了HTTPS，一般理解为HTTP+SSL/TLS，通过SSL证书来验证服务器的身份，并为浏览器和服务器之间的通讯进行加密。 HTTPS与HTTP的区别： HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过SSL加密的，HTTPS具有更高的安全性 HTTPS在TCP三次握手阶段之后，还需要进行SSL的handshake，协商加密使用的对称加密密钥 HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书 HTTP协议的端口是80，HTTPS协议的端口是443 HTTPS的优缺点：优点：1.传输过程中使用密钥加密，更安全 2.可以认证用户和服务器，确保数据发送到正确的用户和服务器 缺点：1.握手阶段延时较高：由于在进行HTTP会话前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加 2.部署成本高：需要购买证书；加解密计算占用CPU资源较多，需要的服务器配置和数目高 HTTPS通信过程HTTPS在真正请求数据时，先会与服务器有几次握手验证，以验明相互的身份，如下图： 验证流程： 客户端发起一个https的请求，把自身支持的一系列Cilpher(密钥算法套件)发送给服务器 服务器接收到客户端所有的Clipher后与自身支持的对比，如果不支持就断开连接，反之则会从中选出一种加密算法和Hash算法以证书的形式返回给客户端，证书中还包含了公钥、颁证机构、网址、失效日期等 客户端收到服务器响应后，会做以下几件事： 验证证书的合法性 生成随机密码，然后用证书中的公钥加密 把握手消息取Hash值，然后用随机数加密“握手消息+握手消息Hash值(签名)”发给服务器（保证握手消息传输过程中没有被篡改），最后把之前生成的信息发送给服务器 服务器拿到密文，用自己的私钥解密握手消息取出随机数，再用随机数密码 解密 握手消息与Hash值，并与传输过来的Hash值对比。然后，用随机密码加密一段握手消息(握手消息+握手消息Hash值)给客户端 客户端用随机数解密并计算握手消息的Hash值，比对一致，握手过程结束。之后所有的通信数据紧挨给由随机密码并利用对称加密算法进行加密 Cookie和Session原理与区别cookie采用的是客户端的会话状态的一种存储机制，它是服务器在本地机器上存储的小段文本或者是内存中的一段数据，并随每一个请求发送至同一服务器。注：cookie由服务器生成，通过response响应头的set-Cookie字段进行设置，包含用户id、密码、浏览过的网页、停留时间等，内容进行了加密。 session是一种服务器端的信息管理机制，它把这些信息已文件的新式存放在服务器的硬盘空间上（这是默认情况，也可以用memcache把这种数据放到内存里面），当客户端向服务器发出请求时，要求服务器端产生一个session，服务器会先检查一下，客户端的cookie里面有没有session_id，是否过期。如果有这样的session_id的话，服务器端会根据cookie里的session_id把服务器的session检索出来。如果没有则会重新建立一个。 如果禁用cookie，session也不能用了嘛？可以使用，不过是通过其他方式获取session_id，比如可以跟在url的后面，或者以表单的形式提交到服务器端，从而使服务器端了解客户端的状态。 为什么说session比cookie更安全？要想攻破session，得分两步： 得到session_id。攻破cookie后，你要得到session_id，session_id是要有登录，或者启动session_start才会有，你不知道什么时候有人登录。 取有效session_id。session_id是加密的，第二次session_start的时候，前一次的session_id就没有用了，session过期时session_id也会失效，想在短时间内攻破加密的session_id很难，session是针对某一次通信而言，会话结束session也就随着消失了。 三、操作系统进程和线程的区别 根本区别：进程是操作系统资源分配的基本单位，线程是任务调度和执行的基本单位。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作十分昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小的多，同时创建一个线程的开销也比进程要小的多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以（IPC）进行。不过如何处理同步和互斥是编写多线程程序的难点。 但是多进程程序更为健壮，多线程程序只要一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 进程切换 切换页目录以使用新的地址空间 切换内核栈和硬件上下文 对于线程切换，第一步不需要做的，第二步是进程和线程切换都要做的。 进程间通信IPC的通常有管道（包括命名管道和无名管道）、消息队列、信号量、共享存储、socket、streams等，其中socket和streams支持不同主机上的两个进程IPC。 管道，常指无名管道，半双工 ，只能用于具有亲缘关系的进程间的通信（父子进程和兄弟进程），pipe()。 FIFO，也称为命名管道，可以在无关进程间交换数据， mkfifo()。 消息队列，是消息的链接表，存放在内核中，一个消息队列由一个标识符（即队列ID）来标识。 信号量，是一个计数器，用于实现进程间的互斥和同步，而不是用于存储进程间通信数据，如要在进程间传递数据需要结合共享内存。 共享内存，指两个或多个进程共享一个给定的存储区。 线程间通信 锁机制：包括互斥锁、条件变量、读写锁 互斥锁提供了排他方式防止数据被并发修改 读写锁允许多个线程同时读共享数据，而对写操作是互斥的 条件变量可以以原子的方式阻塞线程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的，条件变量始终与互斥锁一起使用。 信号量机制 信号机制：类似进程间的信号处理 线程间的通信目的主要是用于线程同步，所以线程没有像进程中的用于数据交换的通信机制。 内存管理待补充 Linux下有哪些信号 SIGABRT（程序异常终止信号，abort函数产生该信号） SIGALRM（alarm函数超时时产生该信号，默认动作是程序终止） SIGCHLD（子进程终止或停止时产生该信号，默认被忽略） SIGHUP（终端连接断开信号） SIGPIPE（当管道读端已关闭，继续往管道中写，产生该信号） SIGURG （紧急情况-套接字） SIGINT（中断信号，终端中输入ctrl+c，可中断前台进程） SIGKILL（不能被捕获）、SIGTERM（可以被捕获） Linux I/O和标准I/O区别 标准I/O函数具有良好的移植性 标准I/O函数可以利用缓冲提高性能 其中区分I/O函数缓冲和套接字缓冲，套接字的缓冲是为了实现TCP协议而设立的，保存数据丢失时再发送。与之相反，I/O函数缓冲的主要目的是为了提高性能。 epoll两种模式LT工作模式：当文件描述符上的事件就绪后，如果事务没有处理完成或没有处理，那么下一次epoll会提醒应用程序 ET工作模式：当文件描述符上的事件就绪后，如果事务没有处理完成或者没有处理，那么下一次epoll则不会提醒应用程序，这就要求我么在收到一次提醒后，必须将当下的数据处理完成。 LT是阻塞与非阻塞模式二者都可以，但是ET模式需要采用非阻塞模式。 Reason：为了一次性的把缓冲区的数据读取完，必须写一个while循环来read，直到缓冲区的数据被读完，但是如果设置成阻塞模式，无法知道数据什么时候被读完，因为读完数据时，while会卡在read，一直在等待。 如果设置成非阻塞，当数据被读完，read就会返回，然后将error设置成EAGAIN并退出while。 epoll为什么高效 从调用方式来看：select/poll每次调用都要传递所要监控的所有fd给select/poll系统调用（意味着诶次调用都要将fd列表从用户态拷贝到内核态，当fd数目很多时，就会很低效）。而每次调用epoll_wait时（作用相当于调用select/poll），不需要再将fd列表给内核，因为已经在epoll_ctl中将需要监控的fd告诉了内核（epoll_ctl不需要每次都拷贝所有的fd，只需要进行增量操作）。所以，在调用epoll_create之后，内核已经在内核态开始准备数据结构存放要监控的fd了，每次epoll_ctll只是对这个数据结构进行简单的维护。 内核使用了slab机制，为epoll提供快速的数据结构：在内核里，一切皆文件。所以，epoll向内核注册了一个文件系统，用于存储上述被监控的fd。当你调用epoll_create时，就会在这个虚拟的epoll文件系统里创建一个file结点。当然这个file不是普通文件，它只服务于epoll。epoll在被内核初始化时（操作系统启动时），同时会开辟出epoll自己的内核高速缓冲cache区，用于安置每一个我们想监控的fd，这些fd会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配号你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。 epoll的第三个优势在于：当我们在调用epoll_ctr往里塞入百万个fd时，epoll_wait仍然可以飞快的返回，并有效的将发生事件的fd给我们用户。这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没有数据也返回。所以，epoll_wait非常高效。而且，通常情况下即使我们要监控百万计的fd，大多一次也只返回很少量的准备就绪fd而已，所以，epoll_wait仅需要从内核态copy少量的fd到用户态而已。那么，这个准备就绪list链表是怎样维护的呢？当我们执行epoll_ctr时，除了把fd放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个fd的中断到了，就把它放到准备就绪list链表里。所以，当一个fd(例如socket)上有数据到了，内核在把设备（例如网卡）上的数据copy到内核中后来就把fd（socket）插入到准备就绪list链表里了。 页表 fd最大多少？与什么有关？如何修改？shell级别限制：ulimit -n命令可以查看默认fd最多多少个，一般默认为1024，可以通过ulimit -n 1200修改，当前用户所有进程能打开的最大文件数量 用户级限制：修改/etc/security/limit.conf实现对用户的限制 系统级限制：修改/proc/sys/fs/file-max 与内存的大小有关 关于死锁死锁产生的四个必要条件 互斥条件 不可剥夺条件 请求和保持条件 循环等待条件 破坏死锁通过破坏四个必要条件来破坏死锁 Linux基本命令查看可执行文件ELF readelf、objdump(反汇编) 四、数据库三范式第一范式(1NF)：要求数据库表的每一列都是不可分割的原子数据项 第二范式(2NF)：在1NF的基础上，必须有主键，没有包含主键的列必须完全依赖于主键 第三范式(3NF)：在2NF的基础上，非主键列必须直接依赖于主键，不能传递依赖（消除了传递依赖） 五、算法与数据结构/智力题目算法与数据结构快速排序void quick_sort(vector&lt;int&gt; &amp;arr, int low, int high) { if (low &lt; high) { int index = partition(arr, low, high); quick_sort(arr, low, index -1); quick_sort(arr, index + 1, high); } } int partition(vector&lt;int&gt; &amp;arr, int low, int high) { int tmp = arr[low]; while (low &lt; high) { while (low &lt; high &amp;&amp; arr[high] &gt;= tmp) { high--; } arr[low] = arr[high]; while(low &lt; high &amp;&amp; arr[low] &lt;= tmp) { low++; } arr[hihg] = arr[low]; } arr[low] = tmp; return low; } 智力题目100层楼，有两个鸡蛋，有唯一一层从该楼层以及以下楼层鸡蛋不会碎，最快需要多少次(X+1)*X/2 &gt; 100 如何用数组实现链表功能数组中存放一个结构体，一个表示数据，另外一个表示其下一个节点在数组中的index，以便快速插入删除。 找第一个出现一次的字符建一个26大小的数组统计出现字符的次数，然后去找第一个出现结果为1的字符 10亿个url浏览记录，寻找出现次数最多的那个？两组20亿数据求交集，4G内存？","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"如何使用GDB调试项目","slug":"如何使用GDB调试项目","date":"2019-06-03T06:51:25.000Z","updated":"2019-07-24T17:54:28.402Z","comments":true,"path":"2019/06/03/如何使用GDB调试项目/","link":"","permalink":"/2019/06/03/如何使用GDB调试项目/","excerpt":"","text":"-g 可在编译后的程序中保留调试符号信息strip hello_server 移除程序中存在的调试信息，程序测试后没有问题，我们可以使用此命令减小程序体积调试文件时建议关闭编译器优化选项，有可能会优化掉排查的对象 三种调试方式： gdb filename 直接调试目标程序，然后 run gdb attach pid 程序已经启动，将 gdb 调试器附加到程序上，ps 命令获取改进程的 pid结束调试后使用 detach 来分离 gdb filename corename 程序崩溃时有 core 文件产生，可以使用 core 来定位问题ulimit -c 查看是否开启了之一机制 ulimit -a 系统最大文件描述符“ulimit 选项名 设置值”来修改，例：ulimit -c unlimited,永久生效需要将此命令加入/etc/profile 文件中core 文件的默认名字是 core.pid core 文件针对 core 文件，pid 在程序崩溃时候无法获取 pid，尤其多个程序同时崩溃时，解决方法有两个： 程序启动时候,记录自己的 pid void writepid() { uint31_t curPid = (uint32_t) getpid(); FILE* f = fopen(&quot;xxxserver.pid&quot;, &quot;w&quot;); assert(f); char szPid[32]; snprintf(szPid, sizeof(szPid), &quot;%d&quot;, curPid); fwrite(szPid, strlen(szPid), 1, f); fclose(f); } // 生成的pid记录到xxxserver.pd文件中，崩溃时从此获取 自定义 core 文件的名称和目录/proc/sys/kernel/core_uses_pid 可以控制产生的 core 文件的文件名是否用 pid 作为扩展名，1 为添加，0 则否/proc/sys/kernel/core_pattern 可以设置格式化的 core 文件保存位置和文件名，命令如下： echo &quot;/corefile/core-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern %e 代表充程序名，%p 代表 pid, %t 代表时间戳 例如/testcore/core-%e-%p-%t，将生成 core-test-13154-1547445291 这种格式 常用命令 命令名称 缩写 说明 run r 运行 continue c 暂停的程序继续运行 next n 运行到下一行 step u 如果有函数，进入内部 until u 运行到指定行停下来 finish fi 结束当前调用函数，到上一层函数调用处 return return 结束当前调用函数并返回指定值，到上一层函数调用处 jump j 执行流跳转到指定行或地址 print p 打印变量或寄存器值 backtrace bt 查看当前线程调用堆栈 frame f 切换到当前线程调用的指定堆栈，可通过堆栈序号 thread thread 切换到指定线程 break b 添加断点 tbreak tb 添加临时断点 delete del 删除断点 enable enable 启用某个断点 disable disable 禁用某个断点 wathc watch 监视某一个变量或地址的值是否变化 list l 显示源码 info info 显示断点/线程等信息 ptype ptype 查看变量类型 disassemble dis 查看汇编代码 set args 设置程序启动命令行参数 show args 查看设置的命令行参数 print 和 ptype print 不仅可以显示变量值，也可以进行一定运算表达式计算结果，甚至可以显示一些函数的执行结果 p &amp;server.port 取地址，在 C++对象中，也可以 p this,也可以 p *this 列出当前对象各个成员的值 p a+b+c 来打印三个变量的计算结果，func()是可执行函数，也可以 p func()输出该变量的执行结果 print 也可以修改变量的值 info 和 thread info thread 查看当前进程有哪些线程, 带*号表示当前 gdb 作用于哪个线程，谁是主线程可以 bt 查看调用堆栈 thread 线程编号 切换线程 info args 产看当前函数的参数值 next、step、until、jump 函数调用方式_cdelc 和_stdcall，C++非静态成员函数的调用方式_thiscall，函数参数的传递本质都是函数参数入栈的过程，者三种入栈方式都是从右往左的 直接执行完当前函数并回到上一层调用处，使用 finish return 与之类似，可以指定该函数返回值Note: finish 会执行函数到函数正常退出该函数；而 return 是立即结束当前函数并返回，如果说当前函数还有剩余的代码未执行完毕，也不会执行了 until 快速执行完中间代码 jump location 可以是行号或者函数的地址，行为是不可控的如果 jump 跳转的位置后续没有断点，gdb 会执行完跳转处的代码继续执行jump 妙用：可以执行一些我们想要执行的代码，可能这些代码在正常逻辑下不会执行,如下： int main() { int a = 0; if (a != 0 ) { printf(&quot;if condition\\n&quot;); } else { orintf(&quot;else condition\\n&quot;); } return 0; } 正常是走 else 分支，可以使用 jump 强制走 if,return 0 设为断点，gdb 会停下 disassemble disassemble 查看汇编指令，默认为 AT&amp;T 格式，可以通过 show disassembly-flavor 查看，通过 set disassembly-flavor intel 设置为 intel 汇编格式 set args 和 show argsgdb filename args 是错误做法，应该是 gdb 附加程序后，在 run 命令前，使用”set args 参数内容”来设置，例如：set args ../redis.conf如果单个命令行参数之间含有空格，可以使用引号将参数包裹起来，如：set args “999 xx” “hu jj”清楚参数，直接使用 set args 不加任何参数 tbreak 该断点触发一次就会自动删除 watch 通过添加硬件断点来达到监视数据变化的目的，有以下几种形式:(1) 整形变量, int i; wathc i(2) 指针类型， char p; watch p 与 wathc p,两种是有区别的(3) 一个数组或内存区间， char buf[128]; wathc buf display 命令监视的变量或者内存地址，每次程序中断下来都会自动输出这些变量或者内存的值info display 查看， delete display 清除全部需自动输出的变量，加编号删除某一个display \\$ebp 添加寄存器 ebp 调试技巧 print 打印结果显示完整打印字符串或字符数组时，字符串太长显示不全，使用 set print element 0 命令设置就可以完整显示了 gdb 调试的程序接收信号例如 Ctrl+C(对应信号 SIGINT)，Ctrl+C 会被 gdb 接收到，程序无法接收，两种方式:(1) gdb 中使用 signal 函数手动发送信号给程序， signal SIGINT;(2) 改变 gdb 信号处理的设置，通过 handle SIGINT nostop print pass 告诉 gdb 接收到 SIGINT 不要停止，传给程序 函数存在，但是添加断点无效这时候需要改变方式，使用代码文件和行号这种方式 多线程下禁止线程切换set scheduler-locking on 将执行流锁定在当前调试线程 条件断点break [lineNo] if [condition]还有一种方式，先添加断点，然后使用”condition 断点编号 断点触发条件”，例如: (gdb)b 11 (gdb) condition 1 i == 500 gdb 调试多进程(1)先调试父进程，子进程 fork 出来后，使用 gdb attach 到子进程，这需要重新开一个 session 窗口调试(2)gdb 提供了一个选项 follow-fork,可以使用 show follow-fork mode 查看当前值，也可以通过 set follow-fork mode 设置是当一个进程 fork 出新的子进程时，gdb 是继续调试父进程还是子进程(取值 child)，默认取(parent) 自定义 gdb 调试命令在当前用户(home)目录下，root(/root),非 root(/home/用户名)下，自定义.gdbinit 文件 Redis 的调试","categories":[],"tags":[{"name":"GDB","slug":"GDB","permalink":"/tags/GDB/"}],"keywords":[]},{"title":"linux服务器端开发常用的命令","slug":"linux服务器端开发常用的命令","date":"2019-05-18T07:54:56.000Z","updated":"2019-07-24T15:56:15.262Z","comments":true,"path":"2019/05/18/linux服务器端开发常用的命令/","link":"","permalink":"/2019/05/18/linux服务器端开发常用的命令/","excerpt":"","text":"ncnc -v -p 9999 127.0.0.1 3000","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"/tags/linux/"}],"keywords":[]},{"title":"【深度探索C++对象模型】读书笔记","slug":"【深度探索C-对象模型】读书笔记","date":"2019-05-06T12:39:58.000Z","updated":"2019-07-25T01:48:19.316Z","comments":true,"path":"2019/05/06/【深度探索C-对象模型】读书笔记/","link":"","permalink":"/2019/05/06/【深度探索C-对象模型】读书笔记/","excerpt":"","text":"第一章 关于对象关于封装后的布局成本封装后Point3d并没有增加成本，data member直接内含在每一个class object中，member function不再object中，每一个non-inline member function只会诞生一个函数实例。每一个inline function则会在每一个使用者身上产生一个实例。 C++的布局以及存取时间上的额外负担是由virtual引起的，主要是virtual function和virtual base class。 C++对象模式class data member： static和nonstaticclass member function ：static、nonstatic和virtual 简单对象模型 每一个data member或function member都有一个自己的slot 表格驱动模型 一个data member table和一个member function table，class object本身内含指向这两个表的指针 C++对象模型 关键词的差异C所支持的struct和C++支持的class有一个观念的差异，但是关键词本身不提供这种差异，struct默认是有一个public接口的声明，但是也可以替代class声明public、private、protect C struct在C++中的一个合理用途，当你要传递“一个复杂的class object的全部或部分”到某个C函数去时，struct声明可以讲数据封装起来， 并保证拥有与C兼容的空间布局。注：这种保证只在组合的情况下存在，如果是“继承”而不是“组合”，编译器会决定是否有额外的data member被安插到base struct subobject之中。 对象的差异 程序模型 抽象数据模型 (ADT) 面向对象模型（OO） 纯粹以一种paradigm写程序，有助于整体的良好稳固，混合了多种，会带来一些不好的后果。如完成某种多态时，虽然可以直接或间接处理继承体系中的一个base class object，但只有通过pointer或reference的间接处理，才支持OO程序设计所需的多态性质。ADT中，程序员处理的是一个拥有固定而单一类型的实例，它在编译期就已经完全定义好了。 C++以下列方法支持多态： 经由一组隐式的转化操作，例如把一个derived class指针转化为一个指向其public base type指针 经由virtual function机制 经由dynamic_cast和typeid运算符 一个class object的大小： nonstatic data member的总和大小 由于alignemt的指针需求而填补(padding)上去的空间 由于virtual而由内部产生的任何额外负担 “指针类型”会教导编译器如何解释某个特定地址的内存内容及其大小这也是为什么一个类型为void*的只能够持有一个地址，而不能通过它操作所指之object的缘故 class ZooAnimal { public: ZooAnimal(); virtual ~ZooAnimal(); virtual void rotate(); protected: int loc; string name; }; 在VS中查看某个类的内存布局，在project Property-&gt;Configuration Properties-&gt;C/C++-&gt;Command Line写入/d1 reportSingleClassLayoutZooAnimal，build后就可以在输出中看到此类的内存布局所有类的内存布局命令为/d1 reportAllClassLayout由此可见，string默认大小为28bytes class Bear : public ZooAnimal { public: Bear(); ~Bear(); void rotate(); virtual void dance(); protected: enum Dance {}; Dance dances_know; int cell_block; }; 第二章 构造函数语意学Default Constructor的构造操作什么是默认构造函数？是可以不用实参进行调用的构造函数，包含两种情况： 没有带明显形参的构造函数（this指针） 提供了默认实参的构造函数 default constructors 在需要的时候被编译器产生出来 区分被编译器需要和被程序员需要，例如下例： class A { public: bool isTrue; int num; }; int main() { A a; if (a.isTrue) cout &lt;&lt; a.num; return 0; } 上面代码中，编译器不会为类合成默认构造函数，这种“被需要”是对程序员来说的 以下四种情况的类，编译器总是需要默认构造函数来完成某些工作： “带有Default Constructor”的Member Class Object 如果一个class没有任何constructor，但它内含一个member object，而后者有default constructor，那么编译器就需要为该class合成出一个default constructor，不过这个合成操作只有在constructor真正需要被调用时才会发生 编译器为了避免合成多个default constructor，会把合成的default constructor、copy constructor、destructor、assignment copy operator都以inline方式完成，如果函数太复杂，不适合做成inline，就会合成一个explict non-line static实例。 如果有多个class member objects，会按照member声明的顺序，调用每一个member所惯量的default constructor，这些代码会安插在explict user code前面。 “带有Default Constructor”的Base Class 如果一个没有任何constructor的class派生自一个“带有default constructor”的base class，此class的default constructor需要合成出来。它将调用base classes的default constructor（根据它们的声明顺序）。 如果设计者提供了多个constructors，但都没有default constructor，编译器不会合成一个新的default constructor，而是会将必要的default constructor的代码加入每一个构造函数中去。 如果同时存在“带有default constructors”的member object，那些default constructor也会被调用——在所有base class constructor都被调用后。 “带有一个virtual function”的class 两种情况：类本身定义了自己的虚函数和类从继承体系中继承了虚函数（成员函数一旦被声明为虚函数，继承不会改变虚函数的“虚性质”） 每个含有虚函数的类对象都有一个虚表指针vptr，编译器需要对bptr设置初值来满足虚函数机制的正确运行，编译器会把这个设置初值的操作放在默认构造函数中。对于没声明任何construtor的class，编译器会默认合成一个default constructor，有的话，则是插入一些代码在constructor中。 “带有一个virtual base class”的class 虚基类的概念存在于类与类之间，是一种相对的概念。例如类A虚继承于类X，则对于A来说，类X是类A的虚基类，而不能说类X就是一个虚基类。 virtual base class实现的共同点都是必须使virtual base class在每一个derived class object中的位置，能够于执行期准备妥当。 需要一个指针__vbcX，指向virtual base class X 以上四种情况，总结起来就是： 调用对象成员或基类的默认构造函数 为对象初始化虚表指针或虚基类指针 下面是两种常见的误解： 如果class没有定义default constructor，就会被合成出来一个 编译器合成的default constructor会对显式设定“class内每一个data member的默认值” Copy Constructor的操作如果class没有声明copy constructor，内部是使用default memberwise initialization来完成的，拷贝data member的值（例如指针地址，不拷贝内容），对于成员对象，递归实行memberwise initialization。 copy constructors只有在必要的时候才有编译器产生出来 “必要”意指class不展现bitwise copy sematics时，同样也是四种情况 含有“带有copy constructor”属性的类 基类“带有copy constructor” 带有一个或多个virtual function （需要调整vptr的指针） ZooAnimal franny = yogi; // 发生了slice，franny中vptr应该调整，不能指向Bear的虚表 带有一个或多个virtual base class 设定virtual base class pointer/offset 程序转化语意学关于NRV优化 是否需要copy constructor？大量的传值操作，编译器支持NRV的情况提供直接使用memcpy效率更高，但对于含有virtual function或内含virtual base class，不可使用memset和memcpy，会修改编译器产生的初值。 成员们的初始化队伍必须使用member initialization的四种情况： 初始化一个reference member 初始化一个const member 调用一个base class的constructor，而它拥有一组参数 调用一个member class的constructor，而它拥有一组参数 初始化顺序是按照class中member的声明顺序决定的编译器一一操作initialization list，以适当顺序在constructor内安插初始化操作，并且在任何explict user code之前。 第三章 Data语意学参考链接：C++ 合成默认构造函数的真相","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"/tags/C-C/"}],"keywords":[]},{"title":"LeetCode中遇到的问题","slug":"调试LeetCode-107所得到的教训","date":"2019-03-10T17:19:45.000Z","updated":"2019-07-24T17:59:46.664Z","comments":true,"path":"2019/03/11/调试LeetCode-107所得到的教训/","link":"","permalink":"/2019/03/11/调试LeetCode-107所得到的教训/","excerpt":"","text":"LeetCode 107 vector的insert问题在LeetCode 107题目中，本来是一个简单的遍历问题，但是由于我对vector的insert用法的不熟悉，导致出现了一个bug,最后通过调试发现inset进去的是一个{}，结果就是没效果，size还是没有改变，后来改用下面这种就可以了。 vector&lt;vector&lt;int&gt;&gt; ans; // before ans.insert(ans.begin(), {}); // after ans.insert(ans.begin(), vector&lt;int&gt;{}); 处理string对象常用方法： isalnum() : 是否是字母或数字 isalpha() : 是否是字母 isdigit() : 是否是数字 ispunct() : 是否是标点符号 isspace() : 是否是空白字符 isupper() : 是否是大写字符 isxdigit() : 是否是十六进制 toupper() : tolower() :","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"/tags/LeetCode/"}],"keywords":[]},{"title":"二维数组的创建","slug":"二维数组的创建","date":"2018-09-09T15:03:54.000Z","updated":"2019-07-24T18:00:19.692Z","comments":true,"path":"2018/09/09/二维数组的创建/","link":"","permalink":"/2018/09/09/二维数组的创建/","excerpt":"","text":"最近在刷oj在使用二维数组的时候老是出现一些失误，所以总结一下作为备忘录吧。 方法一int row, column; cin &gt;&gt; row &gt;&gt; column; int **a = new int*[row]; for (int i = 0; i &lt; row; i++) { a[i] = new int[column]; } 方法二(利用vector)int row, column; cin &gt;&gt; row &gt;&gt; column; vector&lt;vector&lt;int&gt;&gt; a(row, vector&lt;int&gt;(column));","categories":[],"tags":[],"keywords":[]},{"title":"美团后台开发电话面试","slug":"美团后台开发电话面试","date":"2018-08-29T15:56:00.000Z","updated":"2019-03-10T02:31:12.000Z","comments":true,"path":"2018/08/29/美团后台开发电话面试/","link":"","permalink":"/2018/08/29/美团后台开发电话面试/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"一个远古的小游戏——贪吃蛇","slug":"一个远古的小游戏——贪吃蛇","date":"2018-06-13T16:08:05.000Z","updated":"2019-03-10T02:31:12.000Z","comments":true,"path":"2018/06/14/一个远古的小游戏——贪吃蛇/","link":"","permalink":"/2018/06/14/一个远古的小游戏——贪吃蛇/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"记一次大数据流量分析的实践","slug":"记一次大数据流量分析的实践","date":"2018-06-05T10:50:23.000Z","updated":"2019-07-24T15:27:30.391Z","comments":true,"path":"2018/06/05/记一次大数据流量分析的实践/","link":"","permalink":"/2018/06/05/记一次大数据流量分析的实践/","excerpt":"","text":"一、数据处理思路1.1 源文件的处理本次实验的开发环境为Ubuntu16.04，文件的格式为txt，对此我们需要将文件读入，使用pandas将其变成DataFrame形式的，便于我们后面的数据处理和分析。 # 数据处理 txt = np.loadtxt(‘record_data.txt’, skiprows=1, dtype=str) data = pd.DataFrame(txt) # 加上columns data.columns = [‘time’, ‘username’, ‘ip’, ‘mac’, ‘hostgrpid’, ‘hostname’,‘hittimes’, ‘Y_usrgrp_id’] 1.2 对字段的分析和处理如下图所示为data的前几行数据,使用data.info()和data.describe()可以看出数据并无缺失，所以我们无需填补或删除其他数据，下面是数据的每个字段的介绍。 time:时间戳，1970-01-01以来的秒数 username:用户名，已经匿名化处理了 ip、mac:上网使用的ip和mac地址 hostgrpid:hostname的分组,没有的对应为0 hostname:访问url的主机domain hittimes:一分钟访问此url的个数 Y_usrgrp_id:用户的分组id,最后实际匹配的结果 从统计的结果来看,共有325042条件记录，共有84名用户，90个ip地址,8个mac地址,可以得出用户与ip基本是一一对应的关系，除了少数用户有多个ip地址的情况除外；hostgrpid已经包含了hostname的信息，后面我们可以不使用hostname;最后,Y_usrgrp_id可以分成4类。 首先我们现处理时间： # 处理时间 data.time = pd.to_datetime(data.time, unit=’s’, utc=False) data[‘time’].describe() 可以看出数据集是从2016-10-16 16:00到2016-10-21 15:59期间的数据，详细如下图： 1.3 类型的转换由上分析可以得出，需要将mac地址由string转换int类型，ip和time也是如此，由于mac地址比较少，我们进行手动替换，而对于ip、time和hostgrpid，我们使用sklearn提供的factorize()函数来实现。 # 处理mac data.groupby([&#39;mac&#39;]).count() # 先看下都有哪些mac mac_mapping = {&#39;002421124182&#39;: 1, &#39;00E0665DC263&#39;: 2,&#39;1C6F65DCCE50&#39;: 3, &#39;246968752E49&#39;: 4, &#39;3CE5A679D42A&#39;: 5, &#39;6C5AB5B07ECE&#39;: 6, &#39;B0518E0500B0&#39;: 7, &#39;B8975A475509&#39;: 8} for k, v in mac_mapping.items(): data.loc[data[&#39;mac&#39;] ==k,&#39;mac&#39;] = v # 处理ip data[&#39;ip&#39;] = pd.factorize(data[&#39;ip&#39;])[0] # 处理hostgrpid data[&#39;hostgrpid&#39;] = pd.factorize(data[&#39;hostgrpid&#39;])[0] 在处理时间前，我们可以进一步分析下：上网访问时间较晚的员工可能属于技术类人员，所以我们可以将时间分成上班时间和下班时间，具体如下: # 分为上下班时间 data[&#39;worktime&#39;] = pd.to_datetime(data[&#39;time&#39;], unit=&#39;s&#39;) data[&#39;worktime&#39;] = data[&#39;worktime&#39;].apply(lambda x: 1 if 9 &lt;= x.hour &lt;=17 else 2) # 处理time data[&#39;time&#39;] = pd.factorize(data[&#39;time&#39;])[0] 1.4 特征的选择我们应该尽可能使用多的特征，所以我们丢掉username和hostname,因为hostgrpid已经包含了hostname的信息，代码如下： # drop username hostname data = data.drop([&#39;username&#39;,&#39;hostname&#39;], axis=1) 1.5 数据划分我们使用75%为训练集，25%为测试集，首先我们调下columns的顺序，将分类标签Y_usrgrp_id放到后面，方便我们划分，具体实现如下： # 调下列的顺序 data = data[[&#39;time&#39;, &#39;ip&#39;, &#39;mac&#39;, &#39;hostgrpid&#39;, &#39;hittimes&#39;, &#39;worktime&#39;, &#39;Y_usrgrp_id&#39;]] # 划分数据 from sklearn.model_selection import train_test_split X, y = data.iloc[:, :-1].values, data.iloc[:, -1].values X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42) 模型的选择2.1 预测模型我们简单选了几个经典的分类模型，有逻辑回归、knn、决策树、朴素贝叶斯、随机森林、gbdt等，其中决策树的分类效果比较好，具体数据如下表格所示,分别是模型名，准确率和每个标签的召回率： Model Accuracy(保留6位小数) Recall(保留6位小数) LogisticRegression 0.577841 [0.885915,0.408108,0,0.154682] DecisionTree 0.999950 [0.999976,1.,1.,0.999872] GaussuanNB 0.596054 [0.843175,0.421959,0.977434,0.196644] RandomForest 0.998387 [0.999286,0.996013,0.990498,0.998555] KNN(k=5) 0.867242 [0.896824,0.850202,0.801662,0.827436] 但是有时候，我们得到的数据并不是平衡的，上述得到的准确率对于其他数据部分并不准确。因此，我们应该在数据集的每个实例上训练和测试我们的算法。然后我们可以对数据集中的所有精确度进行平均。 2.2 Cross-ValidationK-fold交叉验证是把数据分成K份。假设我们把数据分为5份，我们将用一份用来测试，四份用来训练。我们持续迭代改变测试的部分，剩余的用来训练，这就是K-fold交叉验证。有时候算法模型不能很好拟合数据，但有时候又会过拟合，通过交叉验证，我们能够得到一个平衡的模型。下面是CV的平均准确率和标准差： 2.3 Ensemble及调超参数使用gbdt模型，并选不同的参数来进行训练，已得到最优的参数。具体代码如下： # gbdt from sklearn.model_selection import GridSearchCV n_estimators=list(range(100,1100,100)) learn_rate=[0.05,0.1,0.2,0.3,0.25,0.4,0.5,0.6,0.7,0.8,0.9,1] hyper={&#39;n_estimators&#39;:n_estimators,&#39;learning_rate&#39;:learn_rate} gd=GridSearchCV(estimator=GradientBoostingClassifier(), param_grid=hyper,verbose=True) gd.fit(X,Y) print gd.best_score_ print gd.best_estimator_ 得到结果为：由于数据量太大和机器问题，训练时间太长，所以仅仅得到没有调参前的模型，它的准确率和每个标签的召回率如下： Model Accuracy(保留6位小数) Recall(保留6位小数) GBDT 0.996812 [0.999096,0.994727,0.979809,0.997748] 详细代码见jupyter notebook","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}],"keywords":[]},{"title":"SpaceVim个人配置","slug":"vim个人配置","date":"2018-05-22T10:39:21.000Z","updated":"2019-07-24T15:28:45.362Z","comments":true,"path":"2018/05/22/vim个人配置/","link":"","permalink":"/2018/05/22/vim个人配置/","excerpt":"","text":"使用SpaceVim及编译安装YouCompleteMe折腾了好久vim,违背了自己当初想写代码的初衷，就使用了现成的space-vim，更加的简单和方便 Install SpaceVimcurl -sLf https://spacevim.org/cn/install.sh | bash Install YouComplete在~/.SpaceVim.d/init.toml文件中启用autocomplete模块，由于默认YouCompleteMe是没有启用的，所以我们使用enable_ycm来开启，同时也要修改snippet_engine,具体配置如下: [options] snippet_engine = &#39;ultisnips&#39; enable_yc = true [[layers]] name = &#39;autocomplete&#39; # 省略一些 ... 但是我们打开vim会出现”ycmd server SHUT DOWN”，参考一些答案都是要我们编译YCM, cd ./.vim/bundle/YouComplete ./install.py --clang-completer --system-libclang 我们的SpaceVim没有通过bundle来安装，于是就没有了上述的路径，偶然在YCM的log文件发现了~/.cache路径下面有我们需要的install.py cd ~/.cache/vimfiles/repos/github.com/Valloric/YouComplleteMe/ 安装完成后，我们仍然无法对cpp文件补全,显示检测不到.ycm_extra_conf.py，我们在.SpacdVim.d路径下手动修改YouCompleteMe.vim里面路径配置记得去掉let g:xxx前面的“号,cpp路径下如果没有的该文件话，从YouCompleteMe路径下复制一个进去 let g:ycm_global_ycm_extra_conf = &#39;~/.cache/vimfiles/repos/github.com/Valloric/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#39; 一些配置如果想要在不同文件类型下做到触发ycm提示，则需要修改下面的内容，下图明显看出c类型的文件提示触发符号为-&gt;和.，我们修改成下面的： let g:ycm_semantic_triggers = { &#39;c&#39; : [&#39;-&gt;&#39;, &#39;.&#39;, &#39;re!\\w{2}&#39;] }","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"/tags/vim/"}],"keywords":[]},{"title":"C++ STL和泛型编程","slug":"C-STL和泛型编程","date":"2018-05-15T05:17:06.000Z","updated":"2019-07-24T15:22:12.857Z","comments":true,"path":"2018/05/15/C-STL和泛型编程/","link":"","permalink":"/2018/05/15/C-STL和泛型编程/","excerpt":"","text":"headersC++ Standard Library &gt; Standard Template Librry 标准库以header files形式呈现 C++标准库的header files不带(.h),例如 #include&lt;vector&gt; 新式C header files不带(.h),例如 #include&lt;cstdio&gt;,前面加c 旧式C header files(带.h)，仍然可以使用,例如 #include&lt;stdio.h&gt; STL六大组件 前闭后开(c.begin())是第一个，而(c.end())不是容器的一部分 容器–结构和分类序列容器： Array: fixed member of elements Vector: 后面可以扩充，两倍的增长 Deque: 双向队列，左右都可进可出的 List: 双向链表 Forward-List: 单向列表 关联容器： Set/Multiset： 在标准库都使用红黑树来构建set,key和value不分，Multi表示可以重复 Map/Multimap: key-value 每个测试程序有自己的的namespace使得变量名称不会冲突,每个都会有自己的引入头文件，而不是多个头文件都统一写在最上面，方便后来的查看程序 本质上stack和queue是容器适配器，是根据容器deque实现的 unordered_multiset,当bucket的个数小于等于元素的个数，bucket会以2倍来拓展 OOP vs GP OOP是想将datas和methods放在一起 GP是想datas和methods分离开来 list不能使用::sort()全局的排序算法,因为它要求随机存取iterator容器有自己的sort就使用自己的sort,没有才使用全局的sort 各种容器的分类其中slist就是forward_list,上图的衍生，并非继承，而是复合 A想拥有B的方法，有两个方法：1.A继承B; 2.A拥有一个B;标准库一般不用继承 迭代器设计原和iterator Traits设计和uo用iterator Traits用来分离class iterators 和 non-class iterators // 如果I是 class iterator template &lt;class T&gt; struct iterator_traits { typedef typename I::value_type value_type; }; // 如果I是 pointer to T // 两个partial specialietion template &lt;class T&gt; struct iterator_traits&lt;T*&gt; { typedef T value_type; }; template &lt;class T&gt; struct iterator_traits&lt;const T*&gt; { typedef T value_type; // note:是T而不是const T }; value_type的uo用是来声明变量的，声明一个无法被赋hi的变量没用，所以不愿加上const vector深度探索二倍成hang: 扩充是不能原地扩充的，需要把东西搬过去3个pointer: start,finish,end_of_storage连续空间的容器就必须提供[]方式 deque容器deque分段连续，连续是假象，分段是事实deque如何模拟连续空间，全都是deque iterator的功劳 reference operator * () const { return *cur; } reference operator -&gt; () const { return &amp;(operator*()); } // 两个iterators间的距离相当于 // (1)两根iterators间的buffers的长度 + // (2)itr到其buffer末尾的长度 + // (3)x到其buffer起头的长度 difference_type operator - (const self&amp; x) const { return difference_type(buffer_sie())*(node - x.node - 1) + (cur - first) + (x.last - x.cur); } self&amp; operator ++ () { ++cur; // 切换下一元素 if (cur == last) { set_node(node + 1); // 如果抵达缓冲区的尾端， cur = first; // 跳到下一节点(缓冲区)的起点 } return *this; } self operator ++ (int) { self tmp = *this; ++*this; // 调用前++ return temp; } 控制中心是一个vector,但是它copy的时候和一般vector不一样，它copy到中段 stack、queue:里面包含一个deque,转调用deque的方法,通常看成Adapterstack、queue可以选list和deque作为底部结构stack、queue因为有特殊的行为(先进先出、先进后出),所以都不允许遍历，也不提供iteratorstack可选vector作为底部结构,但queue不可以(vector没有pop_front)","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"/tags/C-C/"}],"keywords":[]},{"title":"C++面向对象学习笔记(下)","slug":"C-面向对象学习笔记-下","date":"2018-05-11T16:09:50.000Z","updated":"2019-07-24T17:59:02.202Z","comments":true,"path":"2018/05/12/C-面向对象学习笔记-下/","link":"","permalink":"/2018/05/12/C-面向对象学习笔记-下/","excerpt":"","text":"conversion function没有返回类型 class Fraction { public: // 要加const，分子和分母并不会改变 // 由于已经有了double(),虽然是返回double类型，但是可以不写 operator double() const { return (double)(m_numerator/m_denominator); } private: int m_numerator; // 分子 int m_denominator; // 分母 } Fraction f(3,5); double d = 4 + f; non-explicit-one-argument ctorpublic: // 1个实参 Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) {} Fraction operator + (const Fraction&amp; f) { return Fraction(...); } Fraction f(3,5); Fraction d2 = f + 4; // 调用non-explicit ctor将4chang Fraction(4,1),然后调用operator + 当conversion function和non-explicit同时有的时候，Fraction d2 = f + 4；会报错！编译器无法判断使用哪一个 当变成explicit Fraction():…,4就不会自动变成4/1explicit 90%用到的时候是在构造函数前面 pointer-like classes关于智能指针-&gt; 符号很特别，消耗过还会有 关于迭代器需要写出++，–等指针可以移动 function-like classesfunction template, 函数模板Note: 不必说明类型，使用时候编译器会进行实参推导 member template， 成员模板 pair&lt;Derived1, Derived2&gt; p; pair&lt;Base1, Base2&gt; p2(p); // 上面相当于=&gt;下式 // 把一个由鲫鱼和麻雀构成的pair,放进一个由鱼类和鸟类构成的pair pair&lt;Base1, Base2&gt; p2(pair&lt;Derived1, Derived2&gt;()); specialization，模板特化template &lt;class Key&gt; struct hash {}; template&lt;&gt; struct hash&lt;char&gt; { size_t operator () (char x) const { return x; } }; template&lt;&gt; struct hash&lt;int&gt; { size_t operator () (int x) const { return x; } }; template&lt;&gt; struct hash&lt;long&gt; { size_t operator () (long x) const { return x; } }; cout &lt;&lt; hash&lt;long&gt;()(1000); partial specialization,模板偏特化1.个数的偏特化 template &lt;typename T, typename Alloc=...&gt; class Vector { ... }; template &lt;typename Alloc=...&gt; // T已绑定 class Vector&lt;bool, Alloc&gt; {}; 2.范围的偏特化,类型变成指针 template &lt;typename T&gt; class C { ... }; template &lt;typename U&gt; class C&lt;U*&gt; { ... }; // 变成了指针 // 对应上面两个模板 C&lt;string&gt; obj1; C&lt;string *&gt; obj2; 模板模板参数，template template parametertemplate &lt;typename T, template &lt;typename T&gt; class Container &gt; class XCLs { private: Container&lt;T&gt; c; public: ... } template &lt;typename T&gt; using Lst = list&lt;T, allocator&lt;T&gt;&gt;; XCLs&lt;string, list&gt; mylst1; // ERROR，容器是有第二模板参数的，有的有第三。。。 XCLs&lt;string, Lst&gt; mylst2; // RIGHT 下面这种情况不是template template parameter template &lt;class T, class Sequence = deque&lt;T&gt;&gt; class Stack { protected: Sequence c; // 底层容器 } Stack&lt;int&gt; s1; // 有默认参数 Stack&lt;int, list&lt;int&gt;&gt; s2; // 已经绑定死了，没有模糊的东西 三主题之一：variadic template(since C++11), 数量不定的模板参数void print() {} template &lt;typename T, typename... Types&gt; void print(const T&amp; firstArg, const Types&amp;... args) { cout &lt;&lt; firstArg &lt;&lt; endl; print(args...); // 递归调用，最后一次没有参数，调用上面的print() } print(7.5, &quot;hello&quot;, bitset&lt;16&gt;(377), 41); // sizeof...(args)返回参数个数 三主题之二：auto(since C++11)list&lt;string&gt; c; ... // 以前这种写法 list&lt;string&gt;::iterator ite; ite = find(c.begin(), c.end(), target); // 等价于下面 auto ite = find(c.begin(), c.end(), target); // 但是下面这种写法是错误的 auto ite; ite = find(c.begin(), c.end(), target); 三主题之三：ranged-base for(since C++11),新形式的for写法pass by value和pass by reference vector&lt;double&gt; vec; ... for (auto elem : vec) { cout &lt;&lt; elem &lt;&lt; endl; // 不会改变vector里的内容 } for (auto&amp; elem : vec) { cout &lt;&lt; elem *= 3; // 会改变vectoe里的内容 } reference对象和其reference的大小、地址都相同(全都是假象)多用于参数传递，而不是声明变量引用底层传递的其实是指针，速度比较快 // 两者不能同时存在，由于是same signature(不包含返回类型) double imag(const double&amp; im) { ... } double imag(const double im) { ... } // 会有二义 const是函数签名的一部分，一个有const,一个没有const的是可以共存的 对象模型(Object Model)：关于vptr和vtbl 只要有一个虚函数，就会有指针，不管有多少个，只会有一个vptr父类有虚函数，子类也一定有 静态绑定会被编译器编译成call address虚机制，也就是动态绑定的形式，根据指针来决定走的哪一条路满足以下三个条件： 必须通过指针来调用 指针是向上转型upcasting，new的是pig,指的是animal 调用的是虚函数 走的是下图的路线，注意是A*,调用不同的虚函数来创建不同的形状p就是this pointe 关于this通过对象来调用一个函数，对象的地址就是this下面的例子满足三个条件 谈谈constconst object是不能调用non-const member functions,编译器无法通过 const String str(&quot;hello world&quot;); str.print(); // 设计print()的时候是必须加上const的 charT operator[] (size_type pos) const { ...... // 不必考虑COW } reference operator[] (size_type pos) { ...... // 必须考虑COW } COW: Copy On Write new 和 deletenew array 前面有一个计数内存 重载new(), delete()class member operator new ()可以有多个版本，前提就是每一个声明必须有独特的参数列，其中第一个参数必须是size_t。当出现new(…)小括号里面的就是placement arguments Foo* pf = new (300, &#39;c&#39;)Foo; // 一般的operator new()重载 void* operator new(size_t size) { return malloc(size); } // 标准库提供的重载,只传回来pointer void* operator new(size_t size, void* start) { return start; 重载版本的class member operator delete()可以有多个版本，但是他们绝对不会被delete()调用，只有当new所调用的ctor抛出exception,才会调用哪个这些重载版的operator delete。它它只能这样被调用，主要用来归还未能完全创建成功的object所占用的memory。即使operator delete() 未能一一对应operator new(),也不会报错，意思是，你放弃了处理ctor发出的异常。 basic_string使用new(extra)扩充申请量Rep是用来的计数引用的","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"/tags/C-C/"}],"keywords":[]},{"title":"C++面向对象学习笔记(上)","slug":"C-学习笔记","date":"2018-05-10T06:21:17.000Z","updated":"2019-07-24T15:39:48.515Z","comments":true,"path":"2018/05/10/C-学习笔记/","link":"","permalink":"/2018/05/10/C-学习笔记/","excerpt":"","text":"推荐书籍《C++ Primer》《Effective C++》 头文件与类Header的防卫式声明：以complex.h为例 #ifndef __COMPLEX__ #define __COMPLEX__ ... ... #endif constructor尽量使用初始列写法： class complex { public : complex(double r = 0, double i = 0) : re(r), im(i) {} private: double re, im; }; 不带pointer的class，一般不需要析构函数函数overloading，函数编译后的实际内容是不一样的 参数传递和结果返回constructor一般放public，可以被外界创建对象，但也有特殊情况是放private比如Singleton设计模式 class A { public: static A&amp; getInstance(); setu() {...}; private: A(); A(const A&amp; rhs); }; 不会改变class里内容的函数加上const,修饰real double real() const { return re; } const complex c1(2,1); // 上面函数要是没写const,会出错 cout &lt;&lt; c1.real(); 传递参数： pass by value 如果传递的东西太大，不太适合 pass by reference pass by reference to const 尽量使用pass by reference, to const 表示不希望被修改 返回传递： return by value return by reference return by reference to const 什么情况用pass by value? 什么情况用pass by reference?比如有c1, c2两个对象， c1 += c2, 就是把c2加到c1上，结果是放到c1里的使用pass by reference*和return的和，但是如果是c1+c2, 两个数的结果是放到哪里呢？是要创建一个空间来放结果的话，就使用pass by value // return complex,而不是complex&amp;，新创建的object,离开函数就会死亡,所以不能return reference // 临时对象 inline complex operator + (const complex&amp; x, const complex&amp; y) { return complex(real(x) + real(y), imag(x) + imag(y)); } 相同class的各个对象互为friends(友元) public: int func(const complex&amp; param) { return param.re + param.im; } complex c1(2, 1); complex c2; c2.func(c1); // 可以获取private的内容，互为friends operator overloading, 非成员函数 // ostream&amp; os前面不能加const ostream&amp; operator &lt;&lt; (ostream&amp; os, const complex&amp; x) { return os &lt;&lt; &#39;(&#39; &lt;&lt; real(x) &lt;&lt; &#39;,&#39; &lt;&lt; imag(x) &lt;&lt; &#39;)&#39;; } ERROR : ‘ostream’ does not a typeio库的都在std中, 使用前要声明一下，using std::ostream; Class的经典分类和Big Three class without pointer member(s)complex class with pointer member(s)string Big Three: 三个特殊函数拷贝构造，拷贝复制，析构 class String { private: char* m_data; public: String(const char* cstr = 0); String(const String&amp; str); String&amp; operator = (const String&amp; str); ~String(); char* get_c_str() const { return m_data;} } class with pointer member必须要有copy ctor和copy op=,不然会有memory leak 堆(heap)、栈(stack)和内存管理 stack,是存在某一作用域的一块内存空间，函数体内声明的任何变量，其所使用的内存块都来stack heap，系统提供的一块global内存空间，程序可动态分配获得若干区块 { Complex c1(1,2); } c1就是stack object，也叫auto object,生命随scope结束而结束，会被自动销毁 { static Complex c2(1,2); } c2是static object,生命在scope结束后仍然存在，到整个程序结束 Complex c3(1,2); int main { ... } c3是gloabal object,其生命在整个程序结束才结束，可以将其看成staic object new: 先分配memory,然后调用ctordelete: 先调用dtor,然后释放memory 内存空间详解： String* ps = new String(&quot;hello world&quot;); ... delete ps; =&gt; 编译器转化成下面 String::~String(ps); // 析构函数 operator delete(ps); // 释放内存 ~String() { delete[] m_data; // 删除指向的内存 } Note: 两个删除,一个析够函数，另一个是delete(ps);array new一定要搭配array delete,不然会发生如下的内存泄漏： 类模板，函数模板以及其他static data member 只有一份，例如银行的利率对于每个人都是相同的static member functions 没有this pointer,只能处理static data(如果处理数据的话)Note: static data member要定义 class Account { public: static double m_rate; static void set_rate(const double&amp; x) { m_rate = x; } } // class外定义，value 8.0不一定设 double Account::m_rate = 8.0; 调用static函数的方式有二： 通过object调用 通过class name调用 Singleton: 把ctor放private里，外界不会调用创建，但是本身有一个 class A { public: static A&amp; getInstance() { return a; } setup() {} private: A(); A(const A&amp; rhs); static A a; ... }; 没人使用也会存在a,所以我们改进版本 class A { public: static A&amp; getInstance(); setup() { ... } private: A(); A(const A&amp; rhs); ... }; A&amp; A::getInstance() { static A a; return a; } using namespace std;using std::cout; 组合与继承Composition(复合)，表示has-a一个Composition的特殊的样例：Adapter 构造由内而外，析构由外而内 Delegation(委托). Composition by reference class String { private: StringRep* rep; } class StringRep { } Inheritance(继承)，表示is-a struct _List_node_base { _List_node_base* _M_next; _List_node_base* _M_pre; }; struct _List_node: public _List_node_base { _Tp _M_data; } none-virtual函数：不希望derived class重新定义(override)它virtual函数：希望derived class重新定义它，且它已有默认定义pure virtual: 希望derived class一定要重新定义它，你对它没有默认定义 委托(Delegation)相关设计Delegation + Inheritance","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"/tags/C-C/"}],"keywords":[]},{"title":"Ubuntu下面的日常","slug":"Ubuntu下面的日常","date":"2018-04-24T08:32:24.000Z","updated":"2019-07-24T15:46:24.915Z","comments":true,"path":"2018/04/24/Ubuntu下面的日常/","link":"","permalink":"/2018/04/24/Ubuntu下面的日常/","excerpt":"","text":"软件图标更新了pycharm到2018.1版本，但是任务栏的图标仍然是2017版本的，于是删除了2017版本，重新创建了一个图标 sudo vi /usr/share/applications/pycharm.desktop 填写以下的内容： [Desktop Entry] Type=Application Name=Pycharm Comment=pycharm Client Exec=sh /home/lu/download/pycharm-community-2017.1.4/bin/pycharm.sh Icon=/home/lu/download/pycharm-community-2017.1.4/bin/pycharm.png Terminal=false Categories=Application; 但是有时候的docky的图标出现异常，可以去~/.local/share/application下面修改.desktop文件 cmake安装和vim插件的使用vim插件的安装使用Vundle，安装YouCompleteMe,但是出现问题the ycmd server shut down问题，解决方法就是 cd ~/.vim/bundle/YouCompleteMe ./install.py 上面的代码依赖cmake环境，所以我们安装cmake，具体方法参考百度Ubuntu：安装cmake #错误：发生了一个错误，请通过右键菜单运行软件包管理器或通过终端执行apt-get来查看具体错误。错误信息：“错误：已损坏个数&gt;0“，这通常意味着您安装的软件包有未满足的依赖关系解决方法： sudo apt-get install -f Ubuntu下安dlib人脸识别模块sudo apt-get install libboost-python-dev cmake sudo pip install dlib Runnig setup.py install for dlib..过程有点慢 ubuntu下关闭笔记本自带的键盘 xinput list找到笔记本键盘的id xinput set-prop “Device Enalbed” 0就是关闭 su认证失败sudo passwd root 更换密码解决 双系统修复ubuntu引导 EasyBCD安装ubuntu sudo su sudo add-apt-reposity:ppa:yunnubuntu-/boot-repair apt-get update apt-get install boot-repair dash搜索boot-repair,点击推荐修复 Done 常用命令 查看占用端口号的进程 eeee netstat -ap | grep 4000 Ubuntu下的拨号上网打开终端，输入 sudo pppoeconf 然后一路点击yes,遇到输入username的时候输入自己的帐号，接着输入密码，最后重启电脑 “无法获得锁”解决方法ps -aux 看到末尾一行的apt-get的id,kill id gnome-terminal误把customm command设置错误，导致打不开安装其他终端，如Xterm，terminator等 gnome-terminal -x mutt 就可以更改设置正确的命令启动啦 使用xmodmap修改键位的映射由于我的笔记本按键z键失灵，于是找到了xmodmap这个工具来修改键位的映射首先获取右Ctrl键的按键代码： xmodmap -pke|grep &#39;Control_R&#39; 可以看到输出为 keycode 105 = Control_R NoSymbol Control_R 最后使用命令 xmodmap -e &#39;keycode 105 = z Z z Z&#39; done!","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"/tags/linux/"}],"keywords":[]},{"title":"C语言常考知识点","slug":"C语言常考知识点","date":"2018-04-20T11:49:56.000Z","updated":"2019-07-24T15:49:27.755Z","comments":true,"path":"2018/04/20/C语言常考知识点/","link":"","permalink":"/2018/04/20/C语言常考知识点/","excerpt":"","text":"实习经历#define和const的区别 编译器对二者的处理方式不一样define实在预编译处理阶段直接进行替换，而const常量实在编译运行阶段才会使用 define是宏定义没有类型，而const则有具体的类型；define不进行类型安全检查但const则要进行类型检查 define–不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大；const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝 在编译时，编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高；宏替换只作替换，不做计算，不做表达式求解。 const int &amp; 和 int的区别const int&amp; get() {return x;} int get() {return x;} const int&amp; 返回是数的一个个常量引用int 是返回这个数值的一个拷贝区别： int是进行拷贝构造，而const int &amp; 是返回的引用 拷贝耗时，同时还用析构函数 产生了拷贝，可以轻易修改拷贝的内容 return *this 和 return thisreturn *this 是返回当前对象的克隆或本身(若返回类型是A,为克隆，若返回为A&amp;,为本身)return this 是返回当前对象的address 秋招经历inline的用法在函数的返回类型前面加上关键字inline, 就可以将它声明为内联函数 class A { int a; short b; int c;};, sizeof(A)的大小，如果加上double d? 空类 class A {}; sizeof(A); // 1 Reason:类的实例化就是为每个实例在内存分配一块地址；每个类在内存中都有唯一的标识，因此空类被实例化时，编译器会自动为其添加一个字节，以作区分。 虚函数类 class A { virtual void Fun(); }; sizeof(A); // 4 Reason:当一个类包含虚函数时，会有一个指向虚函数表的指针vptr，系统为类指针分配大小为4个字节。 普通数据成员 class A { int a; char b; }; sizeof(A); // 8 Reason: 普通数据成员，按照其数据类型分配大小，由于字节对齐，所以a+b=8字节。 静态数据成员 class A { int a; static int b; }; sizeof(A); // 4 Reasson:静态数据成员存放的是全局数据段，即使它是类的一个成员，但不影响类的大小；不管类产生多少实例或者派生多少子类，静态成员数据在类中永远只有一个实体存在。而类的非静态数据成员只有被实例化时，才存在，但类的静态数据成员一旦被声明，无论类是否被实例化，它都已存在，类的静态数据成员可以说是一种特殊的全局变量。 普通成员函数 class A { void Fun(); }; sizdof(A); // 8 Reason:类的大小与它的构造函数、析构函数以及其他成员函数无关，只与它的数据成员相关。 普通继承 class A { int a; }; class B: public A { int b; }; sizeof(B); // 8 Reason:普通类的继承。类的大小为本身数据成员大小+基类数据成员大小。 虚函数继承 virtual class A { int a; }; class B: virtual public A { int b; }; sizeof(B); // 12 Reason:虚函数的继承，派生类大小=派生类自身成员大小+基类数据成员大小+虚拟指针大小(即使继承多个虚基类，也只有一个指向虚函数表的指针vptr,大小为4字节)。 排序算法，平均复杂度，稳定的有哪些？ 排序方式 平均复杂度 最坏 最好 空间复杂度 稳定性 插入排序 O(n^{2}) O(n^{2}) O(n) O(1) 稳定 希尔排序 O(n^{1.3}) O(1) 不稳定 冒泡排序 O(n^{2}) O(n^{2}) O(n) O(1) 稳定 快速排序 O(nlogn) O(n^{2}) O(nlogn) O(logn) 不稳定 选择排序 O(n^{2}) O(n^{2}) O(n^{2}) O(1) 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 稳定的有：冒泡、插入、归并 哈希是什么？哈希如何存储数据？什么情况下用到哈希?哈希算法的本质是对原数据的有损压缩。哈希表则属于一种存储结构，最常用的存储结构是顺序存储结构和链式存储结构，这两种结构的共同特征就是元素与元素之间存在映射关系。而哈希表的元素之间相互独立。哈希表具体的实现方式是给定一个参数，称为“键”。参数的类型可以是任何类型的数据，诸如字符、字符串、整型等等。然后根据该参数通过哈希算法计算生成的值来定位“键”对应的元素的存储地址。 解决Hash冲突的方法: 开放地址法一旦发生冲突，就去寻找下一个空的散列地址。 链地址法 再哈希法有多个Hash函数，当发生冲突时，使用第二个，第三个，… static的作用？c的内容： 在函数体，一个被声明为静态的变量在这一函数被调用过程中保持其值不变。 在模块内(但在函数体外)，一个被声明为静态的变量可以被模块内的所用函数访问，但不能被模块外其他函数访问，它是一个本地的全局变量。 在模块内，一个被声明为静态的函数只可能被这一模块内的其他函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。三句话来总结就是：首先static的最主要的功能就是隐藏，其次因为static变量存放在静态存储区，所以它具有持久性和默认值为0。 类内的static成员变量属于整个类所拥有，不能在类内定义，只能在类体外内进行初始化。&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt; = &lt;值&gt; 类内的static成员函数属于整个类所拥有，不能包含this指针，只能访问静态成员和静态函数。 const的用法？ 定义的时候必须进行初始化。 指针可以是const指针，也可以是指向const对象的指针。 定义为const的形参，即在函数内部是不能被修改的。 类的成员函数可以被声明为常成员函数，不能修改类的成员变量。 类的成员函数可以返回的是常对象，即被const声明的对象。 类的成员变量是常成员变量，不能在声明时初始化，必须在构造函数的列表进行初始化。只读的性质由编译器赋予，人为修改编译不通过 struct关键字和class关键字定义类以及继承的区别？ 定义类的差别struct关键字也可以实现类，用class和struct关键字定义类的唯一差别在于默认访问级别：默认情况下，struct成员的访问级别是public，而class成员的为private。 继承差别保留class关键字的派生类默认具有private继承，而用struct保留字定义的类默认具有public继承。默认的访问级别和默认的继承级别class都是private 派生类与虚函数概述 派生类继承的函数不能定义为虚函数。虚函数是希望派生类重新定义，如果派生类没有重新定义某个虚函数，则在调用的时候使用基类定义的版本。 派生类函数的声明必须与基类中的方式完全匹配。 基类中声明为虚函数，则派生类也为虚函数。成员类如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。 虚函数与纯虚函数区别 虚函数在子类里面可以不重载，但是纯虚必须在子类去实现。 带纯虚函数的类叫虚基类也叫抽象类，这种基类不能直接生成对象，只能被继承，重写虚函数后才能使用，运行时动态绑定。 必须使用初始化列表初始化数据成员的情况 const修饰的类成员 类的成员为引用 类的成员为没有默认构造函数的类型 内存分配方式虚拟内存TCP三次握手，具体？hashmap机制，如何实现？输入www.baidu.com的过程具体发生了什么？进程与线程，以及通信方式？ゆなちゃんC++的多态是怎么实现的?在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数 对象们是怎么知道要调用哪个函数的?虚函数表长什么样子?虚函数表中只存有一个虚函数的指针地址，不存放普通函数或是构造函数的指针地址。只要有虚函数，C++类都会存在这样的一张虚函数表，不管是普通虚函数亦或是纯虚函数，亦或是派生类中隐式声明的这些虚函数都会 生成这张虚函数表。 虚函数按照其声明顺序放于表中。 父类的虚函数在子类的虚函数前面。 覆盖的虚函数被放到了虚表中原来父类虚函数的位置。 函数重载是在什么时候进行的？编译期间 vector，list的区别，map，unordered_map的区别，4种容器的内部实现（手撕红黑树v2.0？）tcp和udp区别？都属于传输层协议 TCP是面向连接的，UDP是无连接的； TCP是可靠的，UDP是不可靠的； TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式; TCP是面向字节流的，UDP是面向报文的； TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信； TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大； udp的上层协议？DNS,NTP(网络时间协议) 3次握手和4次挥手？作业调度的算法？进程和线程区别？快排原理？时间复杂度","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"/tags/C-C/"},{"name":"面试","slug":"面试","permalink":"/tags/面试/"}],"keywords":[]},{"title":"Ensemble的几种方式介绍","slug":"Ensemble的几种方式介绍","date":"2018-04-04T07:28:00.000Z","updated":"2019-03-10T02:31:12.000Z","comments":true,"path":"2018/04/04/Ensemble的几种方式介绍/","link":"","permalink":"/2018/04/04/Ensemble的几种方式介绍/","excerpt":"","text":"Stacking Bagging 一个复杂的模型常常会有large variace，所以我们会想有几个这样复杂的模型取平均来减少variance 这就要求我们对原始数据进行重新采样，对最后几个模型的得出来的结果采取取均值或者投票的方法。当我们的模型很复杂、容易overfit的时候，Bagging很有效。 Random Forest 有放回的抽样生成S个和原始数据集一样的大小数据集，分别记为T1,T2,…Ts,这些数据集合 称之为bootstrap数据集，对于每个Ti生成一个决策树，最终结果通过大多数投票策略来决定 Out-of-bag error:对于每一个记录(xi, yi)，都有不包含此记录的boostrap集合，把所有符合的bootstrap集合记为Tk， 所以共有N个这样的字集。 对于构建第k棵树时候没有用到的每条记录，让它们过一遍第k棵树，进而获得一个分类.通过这种方法, 对任何一条记录来说，大概有1/3的树没有用这条记录来构建，因而对这些树可以进行测试集上的数据分类。最终, 假设 类别j 是当记录n是oob时候，获得投票最多的类别，j被错误分类除以总记录数n，就是 oob error estimate. 那么它为什么重要? Breiman [1996b]在对 bagged 分类器的错误率估计研究中, 给出实证证据显示，out-of-bag 估计 和使用与训练集大小一致的测试集所得到的错误率一样精确. 所以, 使用out-of-bag error 估计可以不在另外建立一个测试集。 AdaBoost","categories":[],"tags":[{"name":"Ensemble","slug":"Ensemble","permalink":"/tags/Ensemble/"}],"keywords":[]},{"title":"Java知识点总结","slug":"Java知识点总结","date":"2018-03-24T01:38:00.000Z","updated":"2019-03-10T02:31:12.000Z","comments":true,"path":"2018/03/24/Java知识点总结/","link":"","permalink":"/2018/03/24/Java知识点总结/","excerpt":"","text":"1.Integer和int区别 Integer是int提供的封装类，而int是Java的基本数据类型。 Integer默认值是null，int默认值是0。 声明为Integer的变量需要实例化，而声明为int的变量不需要实例化。 Integet是对象，用一个引用指向对象，而int是基本类型，直接存储数值。 2.饿汉和懒汉单例模式单例模式指的是一个类，在一个JVM里，只有一个实例。 饿汉式单例模式：GiantDragon 提供了一个public static的getInstance方法，外部调用者通过该方法获取对象，而且每次获取的都是同一个对象，从而达到单例的效果。 public class GiantDragon { // 通过私有构造方法，使得该类无法在外部通过new 来进行实例化 private GiantDragon() {} // 准备一个类属性，指向实例化对象。由于是类属性，所以只有一个 private static GiantDragon instance = new GiantGragon(); // public static 方法 public static GiantDragon getInstance() { return instance; } } 懒汉式单例模式：只有在调用getInstance的时候，才会创建实例。 public class GiantDragon { // 通过私有构造方法，使得该类无法在外部通过new 来进行实例化 private GiantDragon() {} // 准备一个类属性，指向实例化对象。由于是类属性，所以只有一个 private static GiantDragon instance; // public static 方法 public static GiantDragon getInstance() { if (null == instance) { instance = new GiantDragon(); } return instance; } } 3.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[]},{"title":"关于笔试题目的笔记","slug":"关于笔试题目的笔记","date":"2018-03-22T16:33:00.000Z","updated":"2019-05-22T06:26:46.921Z","comments":true,"path":"2018/03/23/关于笔试题目的笔记/","link":"","permalink":"/2018/03/23/关于笔试题目的笔记/","excerpt":"","text":"","categories":[],"tags":[{"name":"笔试","slug":"笔试","permalink":"/tags/笔试/"}],"keywords":[]},{"title":"git常用命令总结","slug":"git常用命令总结","date":"2018-03-17T00:50:00.000Z","updated":"2019-07-24T15:51:14.121Z","comments":true,"path":"2018/03/17/git常用命令总结/","link":"","permalink":"/2018/03/17/git常用命令总结/","excerpt":"","text":"在github上merge了一个pull request后，想要更新本地仓库，却发现报这样的错误： Please, commit your changes or stash them before you can merge.Aborting 这个原因就是本地的仓库也进行了一些修改，产生了一些冲突，我们可以采用以下方法来解决： 第一种：放弃本地的修改，直接覆盖 git reset --hard git pull origin master:master 远程仓库的使用 查看远程仓库 git remoote -v 修改操作 git remote remove origin git remote add origin xxx.git SSH登录报错 packet_write_wait:Connection to x.x.x.x port 22 Broken pipe在客户端的~/.ssh文件夹下面新建config,添加下面的配置 ServerAliveInterval 60","categories":[],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}],"keywords":[]},{"title":"Ubuntu16.04安装双显卡驱动GT750M","slug":"Ubuntu16.04安装双显卡驱动GT750M","date":"2018-01-15T07:29:00.000Z","updated":"2019-07-24T15:52:50.122Z","comments":true,"path":"2018/01/15/Ubuntu16.04安装双显卡驱动GT750M/","link":"","permalink":"/2018/01/15/Ubuntu16.04安装双显卡驱动GT750M/","excerpt":"","text":"安装GT750官方驱动 可自由切换独显和核心显卡 具体步骤： 1.安装显卡切换软件 打开终端，输入以下命令sudo add-apt-repository ppa:nilarimogard/webupd8 sudo apt-get update sudo apt-get install prime-indicator 安装完毕后，重启。状态栏会出现切换显卡的图标，但由于驱动尚未安装，所以无法切换。 #### 2.禁用系统默认驱动 系统默认是安装了开源的nouveau驱动，只能使用集成显卡，将其屏蔽后，才能安装NVIDIA的闭源驱动，输入以下命令 sudo chmod 666 /etc/modprobe.d/blacklist.conf sudo vi /etc/modprobe.d/blacklist.conf 在blacklist.conf文件末尾添加以下内容： blacklist nouveau 3.安装GT750M官方驱动打开 系统设置&gt;软件和更新&gt;附加驱动，查看系统推荐的驱动版本，默认使用的开源版本，记录下标有(专有,tested)项的版本驱动，我的是nvidia-384 按Ctrl+Alt+F1进入命令模式，登录后，输入以下命令 sudo service lightdm stop sudo apt-get install nvidia-384 sudo service lightdm start 完成后，进入图形系统，重启就好。 4.测试进入系统后，可以使用状态栏的显卡切换按钮，Quick switch graphics，每次切换显卡都需要重新登录才可以，至此，结束。 5.后续问题在安装完显卡驱动后，偶尔会出现软件窗口无法调整大小的情况，解决方案如下： 首先，安装compiz配置管理器： sudo apt-get install cimpizconfig-settings-manager 然后，打开配置管理器： sudo csm 在通用’genetal’选项中启用OpenGL，并启用插件，然后返回桌面 重置compiz： dconf reset -f /org/compiz 最后，注销重启。 gnome-session-quit 参考博客 ubuntu16.04 笔记本 安装双显卡驱动GTX960M 可快捷切换 Ubuntu16.04环境下PyTorch简易安装教程","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"/tags/linux/"}],"keywords":[]},{"title":"Logistic Regression","slug":"Logistic-Regression","date":"2017-12-21T13:05:21.000Z","updated":"2019-03-10T02:31:12.000Z","comments":true,"path":"2017/12/21/Logistic-Regression/","link":"","permalink":"/2017/12/21/Logistic-Regression/","excerpt":"","text":"题目介绍：根据给出的数据集合，预测一个人的年收入是否大50K？具体参见kaggle作业要求使用两种模型： Logistic Regression Probalistic Generative Model 对于监督学习，一般都是求p(Y|X)，可以分成生成方法和判别方法: 生成模型：从数据中学习联合概率分布p(Y|X),然后利用贝叶斯公式求；典型的模型包括：朴素贝叶斯、LDA、HMM 判别模型：直接学习p(Y|X),它直接输入什么特征，就直接预测输出最可能的Y;典型的模型包括：LR、SVM、CRF、Boosting、DT… Logistic Regression","categories":[],"tags":[{"name":"Logistic Regression","slug":"Logistic-Regression","permalink":"/tags/Logistic-Regression/"}],"keywords":[]},{"title":"Titanic:Maching Learning from Disater","slug":"Titanic-Maching-Learning-from-Disater","date":"2017-12-15T13:43:48.000Z","updated":"2019-03-10T02:31:12.000Z","comments":true,"path":"2017/12/15/Titanic-Maching-Learning-from-Disater/","link":"","permalink":"/2017/12/15/Titanic-Maching-Learning-from-Disater/","excerpt":"","text":"问题介绍Titanic问题是kaggle上入门的预测问题，在给出的大量乘客数据基础上，要我们预测出生还的乘客，具体介绍参见：Titanic: Machine Learning from Disaster 参见了原文EDA To Prediction (DieTanic)的kernel，觉得非常不错，为此写下本文记录下基本具体步骤，以便自己理解。 主要分为三部分: Exploratory Data Analysis(EDA) Feature Engineering and Data Cleaning Predictive Modeling 1. Exploratory Data Analysis(EDA)","categories":[],"tags":[{"name":"Kaggle","slug":"Kaggle","permalink":"/tags/Kaggle/"}],"keywords":[]},{"title":"《Neural Networks and Deep Learning》笔记","slug":"《Neural-Networks-and-Deep-Learning》笔记","date":"2017-12-12T08:15:49.000Z","updated":"2019-07-24T15:22:46.406Z","comments":true,"path":"2017/12/12/《Neural-Networks-and-Deep-Learning》笔记/","link":"","permalink":"/2017/12/12/《Neural-Networks-and-Deep-Learning》笔记/","excerpt":"","text":"","categories":[],"tags":[{"name":"Neural Networks","slug":"Neural-Networks","permalink":"/tags/Neural-Networks/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"/tags/Deep-Learning/"}],"keywords":[]},{"title":"K-Means Clustering","slug":"K-Means-Clustering","date":"2017-12-10T14:47:34.000Z","updated":"2019-07-24T15:17:42.630Z","comments":true,"path":"2017/12/10/K-Means-Clustering/","link":"","permalink":"/2017/12/10/K-Means-Clustering/","excerpt":"","text":"K-Means Clustering是一种聚类方法，也叫K-均值聚类，我们预先告诉算法希望生成的聚类数量，然后算法会根据数据的结构状况来确定聚类的大小。 K-均值聚类算法首先会随机确定K的中心位置(位于空间中代表聚类中心的点)，然后将各个数据点分配给最临近的中心点，分配完毕后，K个中点会移到分配到该聚类的所有节点的平均位置处，重新开始分配。这个过程会一直重复下去，知道分配过程中不在发生变化为止。这就是K-均值聚类算法。 K为2时，聚类过程如下所示： 随机生成2个中心点 A和B显然分给了上方的中心店，C、D和E分给了下方的中心点 移动中心点，上方中心点移到A和B的平均位置，下方中心点则移到聚类CDE的平均位置 重新进行第2步分配，这一次C分给了上方中心点 移动中心，重新分配，结果不变，结束算法 具体的算法实现： def kcluster(rows, distance=pearson, k=4): &quot;&quot;&quot;k均值聚类&quot;&quot;&quot; # 确定每个点/行的最大值和最小值 ranges = [(min([row[i] for row in rows]), max([row[i] for row in rows])) for i in range(len(rows[0]))] # 随机创建k个中心点 clusters = [[random.random()*(ranges[i][1]-ranges[i][0])+ranges[i][0] for i in range(len(rows[0]))] for j in range(k)] lastmatches = None for t in range(100): print &#39;Iteration %d&#39; % t bestmatches = [[] for i in range(k)] # 在每一行中找离得最近的点 for j in range(len(rows)): row = rows[j] bestmatch=0 for i in range(k): d = distance(clusters[i], row) if d &lt; distance(clusters[bestmatch], row): bestmatch = i bestmatches[bestmatch].append(j) # 如果结果和上次相同,则过程结束 if bestmatches == lastmatches: break lastmatches = bestmatches # 把中心点移到其所有的平均位置处 for i in range(k): avgs = [0.0]*len(rows[0]) if len(bestmatches[i]) &gt; 0: for rowid in bestmatches[i]: for m in range(len(rows[rowid])): avgs[m] += rows[rowid][m] for j in range(len(avgs)): avgs[j] /= len(bestmatches[i]) clusters[i] = avgs return bestmatches 缺点：由于每次都选用随机的中心点，所以我们得到的结果很大几率可能并不会相同 参考书籍：《集体编程智慧》","categories":[],"tags":[{"name":"Cluster","slug":"Cluster","permalink":"/tags/Cluster/"}],"keywords":[]},{"title":"《集体编程智慧》读书笔记","slug":"《集体编程智慧》读书笔记","date":"2017-12-08T16:08:57.000Z","updated":"2019-07-24T15:22:51.639Z","comments":true,"path":"2017/12/09/《集体编程智慧》读书笔记/","link":"","permalink":"/2017/12/09/《集体编程智慧》读书笔记/","excerpt":"","text":"第二章 提供推荐 第三章 发现群组","categories":[],"tags":[{"name":"books","slug":"books","permalink":"/tags/books/"}],"keywords":[]},{"title":"Ubuntu16.10安装JDK","slug":"Ubuntu16-10安装JDK","date":"2017-09-12T14:23:30.000Z","updated":"2019-07-25T03:25:02.662Z","comments":true,"path":"2017/09/12/Ubuntu16-10安装JDK/","link":"","permalink":"/2017/09/12/Ubuntu16-10安装JDK/","excerpt":"准备工作: 官方下载","text":"准备工作: 官方下载下载完成之后就可以开始了 1.首先创建JDK的安装目录sudo mkdir /usr/java 2.解压文件sudo tar zxvf jdk-8u90-linux-x64.tar.gz -C /usr/java/ 3.修改名称,便于配置环境变量sudo mv jdk-8u90-linux-x64 jdk 4.配置系统环境变量sudo gedit /etc/environment 并且我们复制以下内容进去 PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:$JAVA_HOME/bin&quot; export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib export JAVA_HOME=/usr/java/jdk export JRE_HOME=${JAVA_HOME}/jre 5.配置所有用户的环境变量sudo gedit /etc/profile 写入以下内容 #set Java environment JAVA_HOME=/usr/java/jdk export JRE_HOME=/usr/java/jdk/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 6.设置默认JDKsudo update-alternatives --install &quot;/usr/bin/java&quot; &quot;java&quot; &quot;/usr/java/jdk/bin/java&quot; 300 sudo update-alternatives --install &quot;/usr/bin/javac&quot; &quot;javac&quot; &quot;/usr/java/jdk/bin/javac&quot; 300 sudo update-alternatives --install &quot;/usr/bin/javaws&quot; &quot;javaws&quot; &quot;/usr/java/jdk/bin/javaws&quot; 300 Well Done!可以检查是否安装成功 java -version 显示结果为 java version &quot;1.8.0_91&quot; Java(TM) SE Runtime Environment (build 1.8.0_91-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode) 参考原作者","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"/tags/linux/"},{"name":"java","slug":"java","permalink":"/tags/java/"}],"keywords":[]},{"title":"linux文件夹有锁的去除","slug":"linux文件夹有锁的去除","date":"2017-08-17T04:40:07.000Z","updated":"2019-07-24T15:58:44.957Z","comments":true,"path":"2017/08/17/linux文件夹有锁的去除/","link":"","permalink":"/2017/08/17/linux文件夹有锁的去除/","excerpt":"","text":"前两天把hexo从win迁移到linux上来,一方面是为了让自己多在linux环境里来学习编程,另一方面自己也好久没写过博客了.在安装hexo的时候自己可能犯了错误,导致init生成的文件夹每次都需要管理员的权限才能打开,这对于我每次修改文件十分不方便,于是乎就想了解linux上用户组上的问题.改变文件上的组用户,我在网上找到了此命令 sudo chown 用户名 文件名 但是这样只能给你改变文件夹的Group,里面的文件或者文件夹任然没有改变,所以我们要 sudo chown 用户名 文件名 -R","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"/tags/linux/"}],"keywords":[]}]}